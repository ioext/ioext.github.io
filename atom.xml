<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ioext</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ioext.com/"/>
  <updated>2018-11-07T09:31:44.530Z</updated>
  <id>http://ioext.com/</id>
  
  <author>
    <name>ioext</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开篇词 | 照着做，你也能成为架构师！</title>
    <link href="http://ioext.com/2018/11/07/%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/%E5%BC%80%E7%AF%87%E8%AF%8D-%E7%85%A7%E7%9D%80%E5%81%9A%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E6%88%90%E4%B8%BA%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%81/"/>
    <id>http://ioext.com/2018/11/07/架构/从0开始学架构/开篇词-照着做，你也能成为架构师！/</id>
    <published>2018-11-07T11:11:13.000Z</published>
    <updated>2018-11-07T09:31:44.530Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/public/static/images/架构/从0开始学架构/开篇词/1.jpg" alt="Image text"><br>每个程序员心中都有一个成为架构师的梦想，梦想是美好的，但道路是曲折的。</p><p>我大概在 2006 年开始参与架构设计，原本以为学习架构设计就像学习一门编程语言一样，先学习一下基本的语法，再研究一下细节和原理，然后实践一下就能够快速掌握。但真正实践后才发现，架构设计的难度和复杂度要高很多。从最早开始接触架构设计，到自我感觉初步完整掌握架构设计，至少花费了 6 年时间。等到自我感觉彻底掌握架构设计的精髓，至少花费了 8 年的时间（当然，这个过程中我不是一直在做架构设计）。</p><p>我曾经以为是自己天资愚笨才会这样，后来我带了团队，看到几乎每个程序员在尝试架构设计的时候，都面临着我曾经遇到过的各种困惑和瓶颈。特别是我作为职业等级晋升评委的时候，发现很多同学技术能力很强，业务也很不错，但却卡在了架构设计这部分。我意识到这应该不是个人天资的问题，而是架构设计本身的一些特性导致的。</p><p>我总结几个架构设计相关的特性：</p><ol><li><p>架构设计的思维和程序设计的思维差异很大。<br>架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现。很多程序员在转换为架构师后，很难一开始就意识到这个差异，还是按照写代码的方式去思考架构，会导致很多困惑。</p></li><li><p>架构设计没有体系化的培训和训练机制。<br>大学的课程几乎没有架构设计相关的课程，架构设计的书籍更多的也只是关注某个架构设计点，没有体系化的架构设计书籍，导致程序员在学习上没有明确指导，只能自己慢慢摸索，效率低，容易踩坑。</p></li><li><p>程序员对架构设计的理解存在很多误区。</p></li></ol><p>例如：要成为架构师必须要有很强的技术天分；架构师必须有很强的创造力；架构设计必须要高大上才能体现架构师能力；架构一定要具备高可用、高性能……这些似是而非的误区让很多技术人员望而生畏，还没尝试就已经放弃了。</p><p>得益于移动互联网技术的快速发展，我在加入 UC 后有很多的机会直接参与架构设计，这些架构背后的业务形形色色，包括社交、电商、游戏、中间件、内部运营系统；用到的技术栈差异也比较大，包括 PHP，Java、C++ 等。虽然每次架构设计对我来说都是一个新的挑战，但正好也提供了非常好的机会，让我亲身体验不同的架构设计。在这个过程中，我不断学习、思考、实践、总结、改进、交流，逐步形成了自己的一套架构设计方法论。</p><p>有了这套方法论后，首先，我自己在做架构设计的时候游刃有余，不管什么样的业务，不管什么样的技术，按照这套方法论都能够设计出优秀的架构。在职业等级面评的时候，就算我之前从来没有接触过对方的业务，也能快速理解对方描述的架构和发现其中做得好或者做得不好的地方；其次，在指导其他同事的时候效果明显。原来对架构设计比较迷茫的同学，通过几次结合案例进行的方法论培训，都能够很快地掌握这套方法论并在实践中应用。甚至有很多其他业务线的同学，遇到架构设计的困惑，也来找我交流和指导。</p><p>我是一个很喜欢分享的人，经常在 InfoQ 写文章、在知乎写回答，当看到别人在经过我的指导后恍然大悟甚至醍醐灌顶的那种神态，或者发自内心由衷感谢的时候，我自己也会很有成就感。我在极客时间的专栏《从 0 开始学架构》，将与你分享我的架构设计方法论，希望能够帮助更多怀揣架构师梦想的同学早日实现自己的梦想。</p><p>这个专栏涵盖了我的整套架构设计方法论和架构实践，主要包括以下内容。</p><p>架构基础：我会先介绍架构设计的本质、历史背景和目的，然后从复杂度来源以及架构设计的原则和流程来详细介绍架构基础。</p><p>高性能架构模式：我会从存储高性能、计算高性能方面，介绍几种设计方案的典型特征和应用场景。</p><p>高可用架构模式：我会介绍 CAP 原理、FMEA 分析方法，分析常见的高可用存储架构和高可用计算架构，并给出一些设计方法和技巧。</p><p>可扩展架构模式：我会介绍可扩展模式及其基本思想，分析一些常见架构模式。</p><p>架构实战：我会将理论和案例结合，帮助你落地前面提到的架构原则、架构流程和架构模式。</p><p>通过本专栏的学习，你会收获：</p><p>清楚地理解架构设计相关的概念、本质、目的，避免架构师在实践过程中把握不住重点、分不清主次，眉毛胡子一把抓，导致架构设计变形或者“四不像” 。</p><p>掌握通用的架构设计原则，无论是何种业务或技术，架构师在判断和选择的时候有一套方法论可以参考，避免架构设计举棋不定，或者拍脑袋式设计。</p><p>掌握标准的架构设计流程，即使是刚开始做架构设计的新手，也能够按照步骤一步一步设计出合适的架构，避免某些步骤缺失导致错误的架构设计。</p><p>深入理解已有的架构模式，做到能够根据架构特点快速挑选合适的模式完成架构设计，或者在已有的模式上进行创新，或者将已有的模式组合出新的架构。</p><p>掌握架构演进和开源系统使用的一些技巧。</p><p>好的开始是成功的一半，希望专栏的内容能够有效地帮助你更快地掌握架构设计的技巧，更好地设计出优秀的架构，实现自己心中的技术梦想！</p><p>毕竟，只要你努力，技术的梦想一定会实现！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/public/static/images/架构/从0开始学架构/开篇词/1.jpg&quot; alt=&quot;Image text&quot;&gt;&lt;br&gt;每个程序员心中都有一个成为架构师的梦想，梦想是美好的，但道路是曲折的。&lt;/p&gt;
&lt;p&gt;我大概在 2006 年开始参与架构设计
      
    
    </summary>
    
      <category term="架构" scheme="http://ioext.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="从0开始学架构" scheme="http://ioext.com/tags/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01 | 架构到底是指什么？</title>
    <link href="http://ioext.com/2018/11/07/%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/01-%E6%9E%B6%E6%9E%84%E5%88%B0%E5%BA%95%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://ioext.com/2018/11/07/架构/从0开始学架构/01-架构到底是指什么？/</id>
    <published>2018-11-07T09:30:11.381Z</published>
    <updated>2018-11-07T09:30:11.381Z</updated>
    
    <content type="html"><![CDATA[<p>对于技术人员来说，“架构”是一个再常见不过的词了。我们会对新员工培训整个系统的架构，参加架构设计评审，学习业界开源系统（例如，MySQL、Hadoop）的架构，研究大公司的架构实现（例如，微信架构、淘宝架构）……虽然“架构”这个词常见，但如果深究一下“架构”到底指什么，大部分人也许并不一定能够准确地回答。例如：</p><ul><li><p>架构和框架是什么关系？有什么区别？</p></li><li><p>Linux 有架构，MySQL 有架构，JVM 也有架构，使用 Java 开发、MySQL 存储、跑在 Linux 上的业务系统也有架构，应该关注哪个架构呢？</p></li><li><p>微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当我们谈微信架构时，到底是在谈什么架构？</p></li></ul><p>要想准确地回答这几个问题，关键在于梳理几个有关系而又相似的概念，包括：系统与子系统、模块与组件、框架与架构。</p><h1 id="系统与子系统"><a href="#系统与子系统" class="headerlink" title="系统与子系统"></a>系统与子系统</h1><p>我们先来看维基百科定义的“系统”。</p><blockquote><p>系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。</p></blockquote><p>我来提炼一下里面的关键内容：</p><ul><li><p>1、<b>关联</b>：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台 PC 放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。</p></li><li><p>2、<b>规则</b>：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。</p></li><li><p>3、<b>能力</b>：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。</p></li></ul><p>我们再来看子系统的定义。</p><blockquote><p>子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。</p></blockquote><p>其实子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。<br>按照这个定义，系统和子系统比较容易理解。我们以微信为例来做一个分析。</p><ul><li><p>1、微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。</p></li><li><p>2、朋友圈这个系统又包括动态、评论、点赞等子系统。</p></li><li><p>3、评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。</p></li><li><p>4、评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。例如，MySQL、Redis 等是存储系统，但不是业务子系统。</p></li></ul><h1 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h1><p>模块和组件两个概念在实际工作中很容易混淆，我们经常能够听到类似这样的说法：</p><ul><li><p>MySQL 模块主要负责存储数据，而 ElasticSearch 模块主要负责数据搜索。</p></li><li><p>我们有安全加密组件、有审核组件。</p></li><li><p>App 的下载模块使用了第三方的组件。</p></li></ul><p>造成这种现象的主要原因是，模块与组件的定义并不好理解，也不能很好地进行区分。我们来看看这两者在维基百科上的定义。</p><blockquote><p>软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。</p><p>软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</p></blockquote><p>可能你看完这两个定义后一头雾水，还是不知道这两者有什么区别。造成这种现象的根本原因是，<b>模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。</b></p><p>从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是单元复用。其实，“组件”的英文 component 也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。</p><p>我以一个最简单的网站系统来为例。假设我们要做一个学生信息管理系统，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”“个人成绩模块”；从物理的角度来拆分，可以拆分为 Nginx、Web 服务器、MySQL。</p><h1 id="框架与架构"><a href="#框架与架构" class="headerlink" title="框架与架构"></a>框架与架构</h1><p>框架是和架构比较相似的概念，且两者有较强的关联关系，所以在实际工作中，这两个概念有时我们容易分不清楚。参考维基百科上框架与架构的定义，我来解释两者的区别。</p><blockquote><p>软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。</p></blockquote><p>我来提炼一下其中关键部分：</p><ul><li><p>1、框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。</p></li><li><p>2、框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能。</p></li></ul><blockquote><p>软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。</p></blockquote><p>单纯从定义的角度来看，框架和架构的区别还是比较明显的，<b>框架关注的是“规范”，架构关注的是“结构”。</b> 框架的英文是 Framework，架构的英文是 Architecture。Spring MVC 的英文文档标题就是“Web MVC framework”。</p><p>虽然如此，在实际工作中我们却经常碰到一些似是而非的说法。例如，“我们的系统是 MVC 架构”“我们需要将 android app 重构为 MVP 架构”“我们的系统基于 SSH 框架开发”“我们是 SSH 的架构”“XX 系统是基于 Spring MVC 框架开发，标准的 MVC 架构”……</p><p>究竟什么说法是对的，什么说法是错的呢？</p><p>其实这些说法都是对的，造成这种现象的根本原因隐藏于架构的定义中，关键就是“基础结构”这个概念并没有明确说是从什么角度来分解的。采用不同的角度或者维度，可以将系统划分为不同的结构，其实我在“模块与组件”中的“学生管理系统”示例已经包含了这点。<br>从业务逻辑的角度分解，“学生管理系统”的架构是：</p><p><img src="/public/static/images/架构/从0开始学架构/01-架构到底是指什么/1.png" alt="Image text"> </p><p>从物理部署的角度分解，“学生管理系统”的架构是：<br><img src="/public/static/images/架构/从0开始学架构/01-架构到底是指什么/2.png" alt="Image text"><br>从开发规范的角度分解，“学生管理系统”可以采用标准的 MVC 框架来开发，因此架构又变成了 MVC 架构：<br><img src="/public/static/images/架构/从0开始学架构/01-架构到底是指什么/3.png" alt="Image text"><br>这些“架构”，都是“学生管理系统”正确的架构，只是从不同的角度来分解而已，这也是 IBM 的 RUP 将软件架构视图分为著名的<b>“4+1 视图”</b>的原因。</p><h1 id="重新定义架构"><a href="#重新定义架构" class="headerlink" title="重新定义架构"></a>重新定义架构</h1><p>参考维基百科的定义，我将架构重新定义为：<b>软件架构指软件系统的顶层结构。</b></p><p>这个定义看似很简单，但包含的信息很丰富，基本上把系统、子系统、模块、组件、架构等概念都串起来了，我来详细解释一下。</p><p>首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。</p><p>其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。</p><p>第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我为你梳理了与架构有关的几个容易混淆的概念，包括系统与子系统、模块与组件、框架与架构，解释了架构的定义，希望对你有所帮助。</p><p>这就是今天的全部内容，留一道思考题给你吧。你原来理解的架构是如何定义的？对比我今天讲的架构定义，你觉得差异在哪里？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于技术人员来说，“架构”是一个再常见不过的词了。我们会对新员工培训整个系统的架构，参加架构设计评审，学习业界开源系统（例如，MySQL、Hadoop）的架构，研究大公司的架构实现（例如，微信架构、淘宝架构）……虽然“架构”这个词常见，但如果深究一下“架构”到底指什么，大部
      
    
    </summary>
    
      <category term="架构" scheme="http://ioext.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云的这群疯子</title>
    <link href="http://ioext.com/2018/10/17/%E6%8A%80%E6%9C%AF%E5%9C%88%E5%8A%B1%E5%BF%97/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E8%BF%99%E7%BE%A4%E7%96%AF%E5%AD%90/"/>
    <id>http://ioext.com/2018/10/17/技术圈励志/阿里云的这群疯子/</id>
    <published>2018-10-17T10:04:39.000Z</published>
    <updated>2018-11-07T03:33:36.876Z</updated>
    
    <content type="html"><![CDATA[<p>文 | 史中</p><p>世事安稳，岁月静好。</p><p>电影里才有疯子。麦克墨菲在疯人院里带领一群精神病人揭竿而起，怼天怼地；饿了三天的黑皮为了抢一口面包被店主追上高架桥，末路狂奔；杰克和泰勒在午夜的搏击俱乐部里挥拳相向，鲜血淋漓。屏幕对面，我们把爆米花塞进嘴里，哭成狗或者笑成狗。电影散场，各自回家。</p><p>真正的疯子，从来不看电影。</p><p>他们把别人的目光变成聚光灯，把自己的生活变成真人秀，手提钢刀用肉身串演一个浓重的角色。他们的人生结局无外乎两种：黄袍加身，或者玉石俱焚。</p><p>阿里云这群疯子，就用56度的荷尔蒙，在横跨十年的悠长画布上涂抹了这样一个故事。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/1.jpg" alt="Image text">  </p><h1 id="1、一个大问题"><a href="#1、一个大问题" class="headerlink" title="1、一个大问题"></a>1、一个大问题</h1><p>2008年9月，王坚加入阿里巴巴。</p><p>马云把他从微软亚洲研究院常务副院长的位置挖来，是因为阿里巴巴面临一个重大的危机——公司的“脑力”快不够用了。</p><p>阿里巴巴的“脑力”，其实就是“计算力”。</p><blockquote><p>几亿用户无论是在淘宝剁手，还是支付宝上转账，这一切都要靠巨大的计算力来思考、记忆。<br>恰恰和人一样：<br>如果这个“大脑”记忆被填满，就没办法储存新的商品和交易记录。<br>如果这个“大脑”思维速度跟不上，就没有办法让用户及时下单、付款。</p></blockquote><p>2008年，中国虽然已经加入 WTO，还把国际友人请来热热闹闹地开了一次奥运会，但在科技领域仍然是个标准的“三无”国家：没有自己的操作系统，没有自己的芯片，同样没有自己的计算力系统。所以，购买国外成熟的设备和系统，几乎是 BAT 和所有大国企的唯一选择。</p><p>国外的东西，无外乎“IOE”这三样标配：</p><blockquote><p>I（IBM，服务器提供商，他们提供的服务器俗称“小型机”）<br>O（Oracle，数据库提供商，他们的软件是著名的“甲骨文商业数据库”）<br>E（EMC，存储设备提供商，他们提供的是“集中式存储”）。</p></blockquote><p>鲜有人知，那时的阿里像依赖氧气一样依赖 IOE。</p><p>一个支付宝的同事给了我翻出了当年的数据：2008年，在阿里的IT架构中，淘宝和支付宝使用的绝大部分都是 IBM 小型机、Oracle 商业数据库以及 EMC 集中式存储。</p><p>当年用户激增，数据越来越多，每天早上八点到九点半之间，服务器的处理器使用率都会飙升到 98%。离爆棚就差两个百分点。</p><p>阿里巴巴就像赛道上的跑车：速度飞快，但引擎已经发红，再踩几脚油估计就要冒烟，后果不堪设想。</p><p>可能连马云自己都没有想到，阻碍阿里巴巴增长最迫切的阻力不是商场上的博弈、不是政策的变化，而居然是 IT 基础设施的瓶颈。</p><p>怎么办？花钱继续买服务器和软件啊！</p><p>这话听上去没错。但是有两个小问题：</p><blockquote><p>一个问题是太贵。<br>那时候小型机价格大概是从几十万到百万人民币；商业数据库软件费用差不多几千万，外加一大笔维护费。王坚 08 年刚来阿里时就给马云算了算，按照这样的速度“剁手”，光是买机器和软件就足够让阿里破产。阿里得找到一种成本更低的技术架构。<br>另一个问题是不好用。<br>阿里在08-09年的时候，业务增长速度实在太快。每年都是十几二十倍，IOE 虽然都是美国公司，但事实证明美国的月亮也不会更圆。它们的系统并没有经受过服务几亿人这么大规模的考验，此时已经变得非常难用了。</p></blockquote><p>2008 年中旬，马云召开了内部会议。事情已经刻不容缓，要研发一套新的技术架构来换掉阿里巴巴的旧引擎。</p><p>这个新的计算架构应该是什么样呢？</p><p>首先，它要便宜。</p><p>就像一日和三餐一样，无论去哪家餐厅，都不如自己做饭更实惠。长远来看，自己开发一套计算架构显然是最经济的。</p><p>其次，它要好用。</p><p>为了满足阿里巴巴庞大的计算任务，这套系统至少要比 IOE 表现更好，能同时调度数千台计算机，组成一个巨大无比的“大脑”。</p><p>于是，“阿里云”这个词，第一次出现在公司高层的话语里。而王坚，加盟阿里巴巴之后的职务恰恰是“首席架构师”，他的使命就是从零开始建立这个云计算系统。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/2.jpg" alt="王坚"><br>王坚</p><p>王坚是个理想主义者。</p><p>在他丰满的理想中，这个新架构的每一行代码都要自己来写。但现实骨感：环顾四周，他身边除了几位从微软带来的旧部，几乎一无所有。</p><p>2008年10月，这个想象中属于中国的云计算系统被团队定名为“飞天”，源自中国神话中的形象。</p><p>后来人们说，阿里云是技术驱动型的企业。不过在我看来，最初阿里云应该是起名驱动型的企业。名字倒是起得不错，但作为“三无”国家，底层科技起步较晚的中国在对美国的复杂计算机系统的战争中，几十年都未尝胜绩。</p><p>中国人研究的云计算，会“飞天”还是“坠毁”，旁人心里多多少少是有判断的，只是不便明说。</p><p>说回这个疯狂的计划。</p><p>飞天相当于一个发动机的，而时间紧迫，阿里巴巴准备同时做两件事：<b>一边制造发动机，一边为自己的主力业务淘宝网顺便造一个整车出来。<b></b></b></p><p>当时，淘宝网在计算力方面的主要需求就是“大规模数据计算”。所以，用飞天为淘宝造“大规模数据计算”制造整车的计划就被定名为<b>“云梯计划”<b>。</b></b></p><p>实际上，“云梯计划”关乎阿里的生死，不是儿戏。思来想去，公司内部还是做了两手准备：</p><blockquote><p>1）用一些已有的开源软件为基础，研发一个数据计算系统，这是“云梯1”计划。<br>2）而以“飞天”为基础，纯自研一套数据计算系统，被定为“云梯2”计划。</p></blockquote><p>彼时绝没人想到，五年后的那个下午，这两座通向顶峰的云梯会用怎样的姿态占据画面的中心。千军万马雄列两旁，目睹荣耀的火焰和退潮的海水。</p><p>历史就这样以汹涌的姿态，向那些准备好的和没准备好的人敞开。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/3.jpg" alt="王坚"><br>2009年<br>阿里云成立</p><h1 id="2、招兵买马"><a href="#2、招兵买马" class="headerlink" title="2、招兵买马"></a>2、招兵买马</h1><p>满弓是阿里云的第六位工程师。</p><p>招他进来的，是王坚在微软的旧部，阿里云的第一技术负责人林晨曦。面试结束时，林晨曦歪嘴一笑，提醒满弓：“你加入阿里云之后，要做好随时出差的准备。”</p><p>果然，满弓签完入职合同当天下午，就被“附赠”了一张火车票。他要去天津帮助招聘。</p><p>满弓这样回忆十年前的那个下午：</p><blockquote><p>“阿里研发院” 2008年10月才成立，已经错过了招聘季的黄金时期。但是我们又确实太需要人才了，于是刻不容缓，要再扫荡一下那些大学，把“漏网之鱼”打捞回来。</p></blockquote><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/4.jpg" alt="王坚"><br>2009年<br>阿里云的招聘海报</p><p>跟着阿里云的招聘队伍，满弓跑遍了全国主要的几大城市十几个学校。每到一个学校，只呆三天。</p><blockquote><p>第一天做宣讲，然后马上笔试；第二天统一面试；第三天发 Offer。</p></blockquote><p>彼时的阿里巴巴已经很有名气了。很多错过招聘季的同学喜出望外，一时间各大学校风起云涌奔走相告齐来应聘，虽然从招聘者到应聘者，都没见过云计算长什么样子。</p><p>由于招聘人手实在太少，面对堆积如山的笔试试卷，满弓他们根本判不过来。焦头烂额的满弓擦汗时一回头，看到了同行的 HR 小姐姐。满弓两眼放光，二话不说把她们揪过来，一晚上就教会了她们如何判卷。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/5.jpg" alt="王坚"><br>当时判卷的场景</p><p>经过这样“连滚带爬”的招聘，到了2008年年底，阿里云凑够了了三十位工程师。</p><p>话分两头。</p><p>下有林晨曦招兵买马，上有王坚每天“画饼”。</p><p>马云深受王坚鼓舞。虽然不懂技术，但是他逐渐发现，云计算这件事情的价值比一开始想象中的要大得多。</p><blockquote><p>这是因为云计算系统会制造出一种具有极强弹性的计算力。这样的计算力一方面可以为阿里巴巴添置家当，另一方面还可以“批发零售”给无数中小企业，为未来世界建设了一整套“基础设施”。</p></blockquote><p>这样来看，就把“独善其身的工具”变成了“兼济天下的生意”，这不正是马云创建阿里巴巴的基本信念吗？</p><p>从这一刻开始，马云就对阿里云寄予重望。只要有空，就到阿里云的团队里和林晨曦、满弓这些工程师们一起聊天讨论。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/6.jpg" alt="王坚"><br>马云、王坚<br>和工程师们的合影</p><p>然而，事情发展到这里，就开始有些错位了。</p><p>阿里的很多的业务部门希望的是稳定地在现有系统上加以改进，最好别冒太大风险；</p><p>但飞天团队却黄巾高擎赤膊上阵左右开弓，想依靠一己之力，开发出一套改写世界历史，可以让中国人扬眉吐气的完美云计算系统。</p><p>刚才我说阿里云是“起名驱动型的公司”，你看看这帮疯子给飞天内部模块的命名，就知道他们心里在想什么了：</p><blockquote><p>分布式存储的系统，就像大地一样承载万物，那就叫“盘古”。<br>调度系统，需要“能掐会算”，就用懂得阴阳八卦的“伏羲”命名。<br>结构化存储系统，就用会盖房子的“有巢”。<br>网络通信，就用追日的“夸父”。<br>等等。</p></blockquote><p>飞天团队一片斗志昂扬。</p><p>其他部门的很多领导层，用半信半疑外加慈爱的眼光看着他们。<br><img src="/public/static/images/技术圈励志/阿里云的这群疯子/7.jpg" alt="王坚"> </p><h1 id="3、淘宝的一场战争"><a href="#3、淘宝的一场战争" class="headerlink" title="3、淘宝的一场战争"></a>3、淘宝的一场战争</h1><p>时间不等人，转眼到了2009年。</p><p>在隔壁淘宝网的普通员工中，有人在“隔江犹唱后庭花”，有人却已经感到“山雨欲来风满楼”。</p><p>2009年，小邪刚刚加入阿里一年，在淘宝网参与系统研发。当时他和同事都感觉到，淘宝网面临的矛盾非常明显：</p><blockquote><p>业务并不赚钱，09年只有一个季度勉强盈利。而赚来的这点钱，眼看都要填进去购买服务器和软件产品，入不敷出。</p></blockquote><p>小邪记得很清楚，他昨天刚听说隔壁阿里云准备搞云计算，今天就迎来了一个“特殊的客人”。</p><p>林晨曦走到淘宝网技术团队面前，搬个板凳兀自坐下：“你们淘宝的大数据系统用我们的阿里云架构吧。”</p><p>“代码已经写了多少？”小邪问。</p><p>“几行吧。”林晨曦说。</p><p>事情就这样定下来了。</p><p><b>云梯1、云梯2，两套系统一边搭建，一边在淘宝内部实验，一边承担部分计算任务以缓解现有系统不足的压力。<b></b></b></p><p>当时淘宝技术保障数据库管理员的负责人是后羿。他几次欲言又止，还是硬着头皮在内部会议上宣布了这个消息：<b>淘宝要放弃 Oracle，转投自研的数据库架构了。<b></b></b></p><p>结果，八十多个 Oracle 工程师把他堵在会议室里。“你再说一句试试？”</p><p>他们的愤怒完全合情合理。“如果上边铁了心要干，兄弟们的前途在哪里？”</p><p>最终，一场恶斗转化成了几十个工程师坐在会议室促膝谈心。技术人是讲理的：淘宝已经这么大了，如果现在不刮骨疗毒，自己砸自己的饭碗，将来整个淘宝都会命悬一线，到时候大家还不是沦落天涯。想通了这些，工程师们也冷静多了。</p><p>这八十多个工程师里，包括后来的阿里技术保障部负责人振飞。振飞站出来说：“好，让我们学新技术可以，但是咱们拿事实说话。你后羿敢不敢跟我打个赌？以三年为限，用新技术的淘宝核心交易系统必须达到零故障！”</p><p>后羿咬咬牙，敢！</p><p>但后羿一个人的分量还远远不够重。毕竟淘宝上有这么多业务，这么多买家，这么多卖家，万一数据迁移失败，谁来负责？时任淘宝技术总架构师行癫（现任阿里巴巴 CTO）见状，把心一横，宣布自己和部门也愿意站出来，共同承担技术风险：“干好了我们大家荣誉等身，干坏了要杀要剐我来扛！”</p><p>看到行癫都赌上了自己的身家性命，也就没人再说什么了。</p><p>2009年秋天，轰轰烈烈的 IT 架构升级项目在淘宝网正式启动。一群 Oracle 工程师，就这样含着泪，一点一点亲手拆毁自己安身立命的系统。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/8.jpg" alt="王坚"> </p><h1 id="4、荒野求生"><a href="#4、荒野求生" class="headerlink" title="4、荒野求生"></a>4、荒野求生</h1><p>林晨曦用来“忽悠”淘宝网的“几行代码”，是在北京写出来的。</p><p>2009年春节上班第一天，在北京上地的汇众大厦203这间连暖气都没有的办公室里，一帮工程师一边口呼白气，一边敲出了“飞天”的第一行代码。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/9.jpg" alt="王坚"></p><p>飞天的第一行代码</p><p>说起来，这个地方算是阿里云最早的办公室，但是门口也没个牌子。直到半年后他们搬出大厦，保安都不知道这帮神神叨叨的人究竟是干什么的。（不过十年后的今天，他们的手机里的很多 App 也许都跑在阿里云的服务上。）</p><p>每天，工程师们除了噼里啪啦写代码，还得顺便“荒岛求生”——自己订水、买垃圾桶、修桌椅板凳、修无线网，连茶叶和咖啡都是从自己家带来的。</p><p>不过，他们坚信自己在做的事情还是挺伟大的。“没准将来我们成功了，我们写的飞天第一行代码还能印在T恤上呢！”角落里有人瑟瑟发抖地说。</p><p>那个时候的他们，看上去和一帮戴着眼镜的教徒无异。</p><p>时间马上又到了夏天。北京的夏天，你懂的。当时测试系统的服务器就架在办公室里，这就是个巨大的火炉。大厦的空调不行，还没到七月份，程序员就热得撑不住了。为了降温，每天上午他们都叫冰场送两大块冰来。</p><p>有一次周六，马云来北京，专门到阿里云的办公室去看看。林晨曦赶紧想打开电脑给马老师展示一下自己团队的成果。结果按了半天开关，机器都没反应。他才发现大厦停电。。。马云就这样坐在办公室等了半个小时，直到物业恢复供电才一睹阿里云飞天系统最初的芳容。</p><p>王坚跟马云说，这帮人很能干，每天晚上都加班。马云惊了，在这种地方还能加班？？没过几天，阿里云就搬出了这幢大楼，进入了有空调的办公室。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/10.jpg" alt="王坚"><br>同事们往办公室里运冰</p><h1 id="5、神坑，阿里云"><a href="#5、神坑，阿里云" class="headerlink" title="5、神坑，阿里云"></a>5、神坑，阿里云</h1><p>金融大咖胡晓明，2005 年加入阿里，以办事雷厉风行闻名全集团。</p><p>2009年6月，马云找到胡晓明，准备交给他一个大任：内部创业，做阿里金融的总裁。</p><p>胡晓明信心满怀，准备撸起袖子说干就干。不料，马老师悠悠地说，不要急，你要先答应我两件事。</p><p>马云：第一件事，你只能做100万人民币以下的贷款生意，帮助像当年的我一样借不到钱的创业者。</p><p>胡晓明：理解，这没问题。</p><p>马云：第二件事，你必须跟刚成立的阿里云绑在一起，用他们的技术架构支撑你的服务。</p><p>胡晓明：纳尼？？！！</p><p>这两件事，胡晓明最终都答应了。不过阿里云这帮看上去疯疯癫癫的人，他们技术到底靠不靠谱，胡晓明可是真没底。</p><p>金融不像别的业务，这可是一个数据都不能错，一个字节都不能丢。按照“行业祖训”，打死都得用 IOE 这些国外大厂的基础设施，现在可好，却非得用听上去就让人怀疑的“阿里云”。。。</p><p>“明明可以坐高铁，却偏偏要骑自行车去上海。”当时研发工程师王国涛的吐槽，代表了很多阿里金融同事们的心声。</p><p>但马老师肯定有马老师的道理。阿里金融的同事们只能硬着头皮跟阿里云的朋友们握握手。</p><p>“牧羊犬”是阿里金融的第一个产品，简单来说就是给淘宝商家贷款的项目。吐槽王王国涛回忆：“当时阿里云一边搭建飞天平台，我们就一边在飞天上面开发牧羊犬应用。这就像是开发商一边在造房子，我们一边在室内装修铺地板。”</p><p>飞天果然不负众望。</p><p>数据传输问题、计算稳定性问题、处理速度问题一样都不少，翻版篆版梅花版的错误层出不穷，各种 Bug 形式翻新，永不重复，这叫一个皮。。。</p><p>阿里金融的工程师必须24小时盯着系统，才能防止酿成大错。当时情况危急到了什么程度呢？一位奶爸工程师为了值夜班盯系统，把自己小孩的哭声设成了闹铃。因为只有听到这个声音，他才能在无论多困的情况下从床上弹起来。。。</p><p>这段时间，提到阿里云，阿里金融的程序员们都是“眼睛干干的，有种想哭的心情”。他们的经典吐槽大概是这样：人家的是云计算，我们家的是“人肉云计算”；人家的是“分布式计算”，我们家的是“分步试计算”。。。</p><p>作为合作伙伴，林晨曦每天的表情都有点儿尴尬，出则满脸堆笑地帮阿里金融排除 Bug，入则愁容满面地和同事们一起修改代码。</p><p>眼看就要过春节了，两个项目都快撑不住了。</p><p>被“猪队友”坑得够呛的胡晓明气鼓鼓地带着核心骨干跑到王坚办公室门口“讨说法”。胡晓明这个人，是出了名的“只要认定的事情就一定要办成”，大有在王坚办公室打地铺静坐的架势。王坚无奈，派出所有的技术工程师，驻扎在阿里金融的现场加班开发，只为了“让兄弟团队能过个好年”。</p><p>好不容易捱过了 2009 年，春节过后，阿里云发布了一次大版本升级。升级完成的一瞬间，空气突然安静了：</p><blockquote><p>飞天系统稳定得不像阿里云的作品。。。</p></blockquote><p>阿里金融从一口口呛水的状态，一下子冲出海面。</p><p>巨大的计算力让阿里金融实现了“秒级”放贷。这种技术进步让“小额多次放贷”成为了可能，这就让阿里金融几乎等于开挂，不良贷款率大大低于传统金融机构。也正是因为阿里云“高效低价”的加持，单账户每年的 IT 成本可以控制在1元以内。</p><p>阿里金融，成为了后来的网商银行。他们就这样无意间成为了中国第一个上云的银行。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/11.jpg" alt="image text"><br>胡晓明内心OS：<br>宝宝心里苦，<br>但宝宝要笑 T_T…</p><h1 id="6、“骗子”王坚"><a href="#6、“骗子”王坚" class="headerlink" title="6、“骗子”王坚"></a>6、“骗子”王坚</h1><p>解决了稳定性，阿里云就像抓住了救命稻草，总算可以暂时喘口气。</p><p>这些成绩，也已经成功引起了其他公司的注意。于是 2010 年，在阿里巴巴出发两年后，很多大公司纷纷着手研究自己的云计算技术。</p><p>但所有人都没想到，有一只巨大的怪兽正在必经之路上静静等待着。</p><p>这只怪兽名为“5K”。</p><p>你还记得“云梯1”和“云梯2”两个项目吗？此时，终于轮到他们唱主角了。</p><p>两座云梯，就像“争夺家产”的两兄弟，规则很明确：</p><blockquote><p>1、要想成功肩负起阿里巴巴的底层计算系统，就必须有能力独自调度 5000 台服务器。<br>2、两兄弟谁先跑到 5000 这根线，就“赢者通吃”，继承家业。</p></blockquote><p>而 5000 这个目标，就写为 5K。</p><p>目标就摆在这，但无论是“云梯1”还是“云梯2”，都死活达不到这个指标。</p><p>李超是飞天伏羲调度系统的研发工程师。他用苦逼来形容自己的2010 到 2012。当时他带着同事们没日没夜地加班，收获的就是一个接一个的系统错误。</p><p>就这样，一年过去了，两年过去了。</p><p>王坚是一个性情温和的人，但是那段时间，他几乎天天跟团队拍桌子。</p><p>满弓回忆，每次一开会大家都会把桌子收拾干净，把水杯什么的拿走，以防出现“事故”。</p><blockquote><p>我记得有一次博士（王坚）很生气，砰砰地拍手机。有一个工程师实在受不了了，说博士，你拍的是我的手机。。。</p></blockquote><p>现实不是小说。神兵天降和剧情反转并不存在。纵然他们几乎尝试了所有可能的技术策略，但就是没有一种方案可以成功调度5000台机器。</p><p>2012年底，以开源软件为基础的“云梯1”计划实现了4000台集群调度，而阿里云团队更看好的纯自研的“云梯2”还在1500台集群的数量徘徊。</p><p>越是困难时刻，越会产生分歧。</p><p>实话实说，当时大多数的技术大牛，都觉得用经过全世界验证的 Hadoop 为基础的“云梯1”更有希望，对“云梯2”嗤之以鼻。而阿里云这帮人就是不认，因为根据他们的推断，Hadoop 在4K到5K的路上，肯定会遇到一个不可逾越的沟壑，于是倔强地带着团队大举投入“云梯2”。</p><p>在一片质疑和争吵中，<b>“最寒冷的冬天”<b>就这样降临了。</b></b></p><p>1934年到1936年，从苏区出发到陕北会师，三年长征，工农红军从8万人锐减到3万人。</p><p>从2010年到2012年，在阿里云最艰苦的长征三年，“战损率”只多不少。</p><p>由于没有成绩没有进展，连续几年阿里云整个部门都在集团拿最低分。</p><p>满弓、李超他们开始收到团队同学的辞职书，林晨曦也收到了部下的转岗信。这些邮件，最终都一封不少地塞在王坚的邮箱里。</p><p>一般来说，三年时间足够判断一件事情到底靠不靠谱。“世界末日”那年，人们几乎已经认定了阿里云不可能做出一套云计算系统了。不仅如此，很多阿里的同事都叫王坚“骗子”。开始大家还在背地里说，后来，大家都不再忌讳，公司里流传着很多骗子王坚的笑话。“一个学心理的博士居然当上阿里巴巴的 CTO，心理学学得真好啊！”</p><p>无论是“伏羲”还是“盘古”，这些开天辟地的名字，此时都成为了阿里云这些人要满足“个人野心”的明证，成为了狂妄的代价，成为了“不自量力”的耻辱。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/12.jpg" alt="image text"><br>当时内网论坛里对阿里云和王坚的吐槽</p><p>满弓、李超、飞天总架构师唐洪、林晨曦，他们每天都是低着头上班。今天，左边的工位空了，明天，右边的工位空了。。。</p><p>“谁也不知道王坚当时帮我们抗了多大的压力。。。”李超回忆起那段日子，只说了这么一句话。</p><p>眼看阿里云成立就要满五年了，集团里却风言风语地传着“阿里云要被撤掉”的消息。</p><p>某一天，马云突然召集阿里集团高管开会，所有业务部门的负责人都估计是马云要宣布关掉阿里云的消息，于是纷纷带上自己的技术负责人参会，准备一声令下，就瓜分阿里云的技术人才。</p><p>在 2012 年的阿里云年会上，王坚走上台，他紧紧攥着话筒，几次抬眼望向远处，几次欲言又止，最终泣不成声。这个曾经扬言要用一己之力把中国云计算镌刻在世界科技史上的“疯子”，就那样孤零零站在原地，面对台下黑压压的一群错愕的人。仿佛无数时间的列车在他眼前呼啸飞逝，而他手里没有握着任何一张车票。</p><p>这是阿里云故事里最为人所知的一个细节。但我猜很少有人记得，王坚一边哭，一边说了什么。</p><p><b> 他说：“这两年我挨的骂甚至比我一辈子挨的骂还多。但是，我不后悔。只是，我上台之前看到几位同事，他们以前在阿里云，现在不在阿里云了。。。”<b></b></b></p><p>就像王坚的一位老部下把辞职信交到他手里时，对他说的那样：做云计算的感觉就像集体合围抱一棵大树，谁都知道最终大家的手会连在一起，但谁也不知道那一刻会发生在什么时候。真的真的对不起，我撑不住了。。。</p><p>如果把阿里云所有曾经的员工加起来，可能是现在的好几倍。有太多太多的人都在那段暗淡的日子里离开了。这不怪他们，任何一个能认真判断利弊的人，也许在那时候都应该离开阿里云。也许只有“疯子”，才会选择留下。</p><p>就在阿里云最危急的时候，好友朱珑找到林晨曦，鼓励他离职创业。但林晨曦给朋友撂下一句斩钉截铁的话：“现在我绝对不能走。如果你想等我创业，先让我把阿里云扶上正轨。”</p><p>阿里云苦苦撑着，人心飘摇，流言四起。</p><p>流言终于传到马云耳朵里。</p><p>“我每年给阿里云投 10 个亿，投个十年，做不出来再说。”他对着阿里巴巴集团所有人，斩钉截铁地说。</p><p>这一句话，让所有的流言顺次平息。</p><p>在阿里云年会上，<b>马云做了这样的独白：<b></b></b></p><blockquote><p>我知道，所有留下来的人其实是真正阿里云的精髓。<br>有的时候不是你技术有多强，而是我们有多团结，互相多配合，多支持，多理解。<br>换任何一个公司，吃不消内网上那么多人骂的，我有一段时间也是特别替大家难过，就像我骂儿子可以，我打儿子可以，不允许别人骂我儿子的，要不然我要翻脸的。<br>我没有想过公司内部对阿里云有那么大的意见，我真没想到。但是你们都扛过来了，这是我深以为傲的，如果你们能抗得过内部人骂，抗得过那么多人指责，我们还有什么扛不过未来五年的发展？</p></blockquote><p>李超给我看了这张照片。<br><img src="/public/static/images/技术圈励志/阿里云的这群疯子/13.jpg" alt="image text"></p><p>这是当年参加 5K 项目的同事。他说，这些人中现在只有十几个还在阿里巴巴。<br>李超又给我看了另一张照片。<br><img src="/public/static/images/技术圈励志/阿里云的这群疯子/14.jpg" alt="image text"></p><p>阿里云成立满六年的时候，为所有从第一年走到现在的员工做了一个人偶。所谓的“所有”，只是眼前这五个人偶。满弓和李超就在其中，他们相顾一笑。</p><p>这场长征，从摩肩接踵走到踽踽独行。年轻的人们为了共同的梦想相互温暖，又难免为了各自的梦想互道珍重。只是那些曾经鲜活的伙伴，就这样成为离去的背影，越走越远，消失在视野里，也消失在生命里。</p><p>再多情的看客，恐怕也难解其中滋味。</p><h1 id="7、5K"><a href="#7、5K" class="headerlink" title="7、5K"></a>7、5K</h1><p>阿里云的神坑，不仅“坑”了胡晓明的阿里金融，也在“坑”淘宝网。</p><p>之前说过，淘宝网从2009年就开始了“云梯计划”。到了 2012 年，局面变得有些尴尬：</p><blockquote><p>1、无论是云梯1和云梯2，都没有冲上云计算的技术标准：5K 的规模。<br>2、虽然没达标，但是淘宝网没有选择，只能“赶鸭子上架”，让两架还在试验中的云梯承担一些重要负载。</p></blockquote><p>被刀架在脖子上的行癫心急如焚。</p><p>2013年3月28日，一封来自集团技术保障部架构师云铮的邮件直达高层：</p><blockquote><p>按照数据增量与未来业务增长的情况，云梯1和云梯2两套系统的存储和计算能力将在今年6月21日到达瓶颈。<br>到那时，数据业务将会停滞，淘数据，量子能业务都会受到影响；阿里金融的贷款业务将因为无法进行信用数据运算而中止。</p></blockquote><p>这一天终于来了。人们洪水般的“买买买”为阿里巴巴划定了 Deadline。要想维持正常的业务，他们必须在不到三个月的时间里解决问题。</p><p>这个时候，把飞天推上 5K，几乎已经是唯一的选择了。事到如今，这已经不是阿里云自己的战斗，而是整个阿里巴巴集团的“背水一战”了。</p><p>在这个关头，阿里云需要集团所有人的帮助。</p><p>各个部门的技术大牛迅速组成增援大军列立山头，旌旗飘扬。但是在进入战斗序列之前，一个纠缠了各路大神五年恩怨情仇的问题必须有个了断：</p><blockquote><p>最初，因为要做两手准备，以 Hadoop 为基础的“云梯1”和以飞天为基础的“云梯2”一直并行。这个时候，时局已经紧迫到不允许团队分流，他们必须抛弃掉一个云梯。</p></blockquote><p>抛弃哪个？</p><p>云梯1，依靠开源技术，更加成熟，但几年的实践证明，把它推到 5K 有明显的的技术瓶颈。而且，最核心的技术转向开源系统，也许会让阿里巴巴在未来遇到更多技术制约；</p><p>云梯2，自研技术，难度更大，但它的架构和代码都是基于阿里自身诉求而设计的。自主可控的 5K 一旦成功，就会打下阿里巴巴下一个十年的江山。而一旦失败，后果也将不堪设想。。。</p><p>此时做出任何抉择，都会彻底改变阿里巴巴的历史。但历史又只在彼时彼刻给阿里巴巴一次机会，开弓没有回头箭。所有人的目光都看向王坚。</p><p>王坚说了两个字：“飞天！”</p><p>再没有一句质疑，再没有一丝埋怨。那些曾经看好或者不看好飞天的技术大牛，这个时候撸起袖子一齐杀了进来。</p><p>核心技术系统的正明团队，全员投入 5K 的攻坚战；负责应用集测测试的许呙兢，在得知调度系统的日志自动收集和分析工具缺口严重，二话没说主动请缨；褚霸、多隆、长仁这些分散在各部门的的技术牛人也都冲进来了。各路神仙在这几个月亲近得不分彼此。</p><p>褚霸回忆当时的场景：“早上9点进入项目，11点我们就开始解BUG。” </p><p>就连在电梯里，都会人问阿里云的同事“最近怎么样？需不需要帮忙？”他们来自一些兄弟团队，有负责安全的，有负责集成测试的。</p><p>阿里云自己的同事更是全力冲刺。</p><p>新员工刚刚入职，就立刻被派往“战场”。本来是北京分公司的员工，入职之后直接拉到杭州帮忙 5K 项目。都加入公司两个月了，还不知道自己北京的工位在哪里。</p><p>而一位叫做李泉的同事，连续几个礼拜连轴转，半夜两三点被叫起来解决问题，早晨八点又出现在工位上。被同事封为“李铁人”。</p><p>在最后的测试阶段，杭州和北京两个办公室的同事电话24小时通着，人可以轮班休息，电话不能掉线，那部用来接听的电话都烧得滚烫。</p><p>就这样，一行行代码累积起来，在赛博世界的疆土上一眼望不到边界。他们交错重叠，像从白垩纪开始慢慢累积的地层。直到这片大陆，终于浮出海面。</p><p>2013年6月底，5K进入了最后的稳定性测试。</p><p>怎么测试系统的问题定性呢？之前带领“八十勇士”围攻后羿的振飞，提出了一个真·钢铁直男的测试办法：拔电源。</p><p>他的理由是：“如果这种突然暴力断电都能撑得住，阿里云还有什么不稳定的呢？”</p><p>拉电的同学反复问了三遍：拉吗？拉吗？拉吗？最后才颤抖着双手拉下了电源。</p><p>这一刻，时间停止了，只有机器重新启动的声音。</p><p>四个小时以后，当系统完全恢复运行的时候，很多阿里云同事的背后，已经被冷汗打湿了。经过系统自检，一切正常。虽然还有十台服务器光荣就义。但是，数据毫发无损！</p><p>这一刻，在场见证的人都明白：成了。</p><p>所有的技术路线之争，所有的进退成败之辩，所有的隐忍委屈不甘，所有的怀疑嘲讽忧虑，就在此时此刻突然画上句号。</p><p>盛夏的杭州，阿里巴巴热血翻涌，阿里云的“疯子”们却心如止水。</p><h1 id="8、阿里云这群疯子"><a href="#8、阿里云这群疯子" class="headerlink" title="8、阿里云这群疯子"></a>8、阿里云这群疯子</h1><p>阿里云，成为了中国第一家拥有完整云计算能力的企业。</p><p>2015年，在计算界的奥运会 Sort Benchmark 中，阿里云计算100TB数据排序只用了不到7分钟，把 ApacheSpark 之前创造的23分钟世界纪录一下子缩短了一多半。这说明，中国人研发的云计算系统不仅成功了，而且不比世界上任何现存的云计算系统差。</p><p>成功登顶的“云梯2”，后来更名为 ODPS，“加冕”成为了阿里巴巴各项业务通用的大数据计算平台。</p><p>ODPS 验证成功之后，阿里立刻启动“登月计划”，把所有的数据和计算都迁移到飞天为基础的系统上，全盘替代 IOE 和 云梯1。2013年5月，阿里巴巴最后一台小型机下线。7月，淘宝最后一个Oracle数据库下线。阿里巴巴这台战车，用了五年时间，在超高速行驶中，没有踩一脚刹车，成功更换了发动机。</p><p>因为突破了技术瓶颈，在 5K 之后，ODPS 只用了几个月就冲上了单集群 10K，进而实现了无限制扩展。到 2018年，已经更名为 MaxCompute 的 ODPS 达到了数万台的规模。</p><p>哦对了，还有一件小事。当年振飞和后羿的那场“世纪赌局”，后羿赢了。用了三年时间，新的淘宝核心系统果然实现了零故障。</p><p>这段时间，阿里云也迎来了两个变动：</p><p>2012年秋天，林晨赴约去创业。提及过往，他如此回忆：“阿里云的四年，像是过完了一辈子。以后的事情，都是下辈子的。”他和朱珑创立了依图科技，如今是人工智能领域最炙手可热的公司之一。</p><p>2014年秋天，胡晓明来了。这个当年去王坚办公室“上访”的热血青年，陪着阿里云走过了最漫长艰难的岁月。也正因如此，此时他比任何人都更坚信云计算的力量。</p><p>2015年7月22日，云栖大会北京峰会开幕。新的领导团队第一次在公众面前露面。</p><p>胡晓明任阿里云总裁。李津扛起产品研发，在淘宝网鼎力帮助阿里云的小邪作为技术顾问。等等等等。</p><p>名单里没有王坚。王坚知道，当有人能比他更好地带领阿里云前进的一刻，就是他放手的时候了。</p><p>这个老男孩，此时静静坐在时光的河岸边，痴痴傻笑。梦回少年，肝胆皆冰雪。</p><h1 id="9、另一个奇迹"><a href="#9、另一个奇迹" class="headerlink" title="9、另一个奇迹"></a>9、另一个奇迹</h1><p>在阿里巴巴的云栖小镇，一尊雕像被竖立起来，雕像上只有两个字：“5K”。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/15.jpg" alt="image text"><br>5K雕塑，上面刻着飞天团队所有工程师的名字，无论 Ta 是不是仍然在团队。</p><p>之前有人无心说的那句“没准将来我们成功了，我们写的飞天第一行代码还能印在T恤上呢！”也成为了现实。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/16.jpg" alt="image text"><br>2018年现任阿里云产品总监何云飞<br>身上就穿着“第一行代码T恤”</p><p>2013年，中国企业IT架构升级最好的解决方式，再也不是买来一台新的机器替代掉原有机器，而是采用云计算。</p><p>从这一刻开始，这些疯狂的技术宅才有了服务全世界企业的信心；也正是从这一刻开始，坐镇第一把交椅的传奇总裁胡晓明，带领阿里云进入了“攻城掠地”的时代。</p><p>中国的网站登录阿里云的比例，从20%，上涨到30%，上涨到40%，上涨到50%。全球19个地域，两百多个飞天数据中心顺次点亮。</p><p>每个季度，阿里云都保持同比增长100%，这样逆天的增长速度持续了12个季度。</p><p>2018年初的云栖大会上，在一幅硕大的市场曲线图面前，胡晓明抬起右手，这一秒，时间像是凝固了一般。</p><p>同一年，飞天云计算操作系统获得了一个特别的奖项——中国电子学会15年以来的第一个特等奖。</p><p><img src="/public/static/images/技术圈励志/阿里云的这群疯子/17.jpg" alt="image text"><br>在芯片领域，我们面对美国垄断只得眼睁睁地沉默。</p><p>在操作系统领域，我们面对美国的背影只能艰难追赶；</p><p>但是在云计算这片土地上，从王坚带着一群理想主义者横空出世，到胡晓明把商业战场拉至和亚马逊的 AWS 同一级别。中国人用了十年时间造出的全球第三、亚洲第一的阿里云，不说和美国战为和棋，至少在世界的版图上夺下了堪称广袤的一片疆土。</p><p>如此，阿里云的疯子们，理应赢得光芒和荣耀。</p><p>创业维艰，唯有曾和死神擦肩而过的人，余生才会用十倍的速度奔跑。</p><p>2018年，当年为阿里云对接淘宝立下汗马功劳的小邪正式加入了阿里云，掌管“飞天八部”，阿里云所有的现役主力技术和前沿技术，都归至他麾下。<br><img src="/public/static/images/技术圈励志/阿里云的这群疯子/18.jpg" alt="image text"><br>小邪 蒋江伟</p><p>小邪手中的弹药充足：</p><blockquote><p>2017年发布的神龙云服务器，是对下一代云计算主机的探索。<br>同年发布的 POLARDB，剑指商业数据库 Oracle 和它的继任者 MySQL，也称得上是阿里云未来之星。<br>2018年初，飞天的分布式存储系统“盘古”升级到了 2.0，成为阿里巴巴统一存储平台。<br>2018年秋天的云栖大会上，唐洪、小邪、何导等阿里云大咖悉数登场，发布了飞天2.0。敢称 2.0，是因为他们把野心放到了“万物互联”的下一个20年。<br>如此尝试和未来对话的技术还有很多。</p></blockquote><p>此刻的阿里云，手握历史上最好的一把牌。</p><h1 id="10、尾声"><a href="#10、尾声" class="headerlink" title="10、尾声"></a>10、尾声</h1><p>不久前，王坚受央视《朗读者》节目邀请，回忆了阿里云的创业史。他平静地说：“阿里云是拿命换来的”。<br><img src="/public/static/images/技术圈励志/阿里云的这群疯子/19.jpg" alt="image text"><br>能用命换来梦想，未尝不是幸事。</p><p>君不见，在无数个平行世界中，疯人院里的麦克墨菲最终都越狱失败，被医生切去前额叶，再无还手之力。</p><p>一群理想主义者的长征路上，一片落叶微微改变飞舞的方向，都有可能把他们引向另一个方向，另一种结局。如果重来一次，阿里云也许无法复现今天的疆域和荣耀。但历史没有假设，可叹阿里云这群人从第一天就无来由地相信，中国人有权拥有自己的云计算。</p><p>以身为棋，胜天半子。</p><p>阿里云的创业故事走到了封底。书中悲欢离合，凡此种种，也许只博看客一叹。只有那些经历过这一切的活生生的人，才能在时间的风尘里，循着自己的脚印依稀辨别来路。</p><p>而那些走散的人呢？</p><p>他们也许会在某个秋日回忆起和伙伴同行的日子，心怀感念；他们也许有了新的忙碌的生活，来不及回望；他们也许偶然翻到新闻，看到那年王坚的滚滚热泪；他们也许在饭桌上谈笑风生，聊到当时的兄弟，忽然抬眼望向远方，干掉一杯烈酒。</p><p>我想起一个小故事。</p><p>在最初面试时，有一个大牛程序员和满弓聊过之后，本想再考虑考虑是否入职。但是出门时，他看到了阿里云办公室上的一副对联，原地思考了几秒钟，转身决定马上加入。</p><p>那副对联是这样写的：</p><blockquote><p>代码成就万世基积沙镇海<br>梦想永在凌云意意气风发</p></blockquote><p>任何执拗都会成为过往，只有时间会告诉你对错。</p><p>人们总爱说一句话：认真你就输了。而我更相信另一句话。认输，你才真的输了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文 | 史中&lt;/p&gt;
&lt;p&gt;世事安稳，岁月静好。&lt;/p&gt;
&lt;p&gt;电影里才有疯子。麦克墨菲在疯人院里带领一群精神病人揭竿而起，怼天怼地；饿了三天的黑皮为了抢一口面包被店主追上高架桥，末路狂奔；杰克和泰勒在午夜的搏击俱乐部里挥拳相向，鲜血淋漓。屏幕对面，我们把爆米花塞进嘴里，哭
      
    
    </summary>
    
      <category term="阿里云" scheme="http://ioext.com/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="阿里云" scheme="http://ioext.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>小崔的安全让我牵肠挂肚</title>
    <link href="http://ioext.com/2018/10/15/%E7%A4%BE%E4%BC%9A%E7%83%AD%E9%97%A8/%E5%B0%8F%E5%B4%94%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%A9%E6%88%91%E7%89%B5%E8%82%A0%E6%8C%82%E8%82%9A/"/>
    <id>http://ioext.com/2018/10/15/社会热门/小崔的安全让我牵肠挂肚/</id>
    <published>2018-10-15T14:43:25.000Z</published>
    <updated>2018-10-15T06:44:09.180Z</updated>
    
    <content type="html"><![CDATA[<p>​​原创： 艾丰  码字工匠老詹  今天</p><p>在微信上看了崔永元的讲话视频和有关信息，知道他受到了人身安全威胁，一贯睡眠很好的我，竟然夜不能寐，失眠了。索性爬起来，写下这段文字。</p><p>崔永元真的没有危险吗？</p><p>到底由谁来保护崔永元？</p><p>崔永元因为揭露影视界的丑闻，得到了广大群众的赞誉，但也受到一些非议，更值得注意的是，他已经受到了生命的威胁！</p><p>所以，人们不能不为小崔的安全牵肠挂肚。</p><p>也许有人说，他们不敢，只是威胁威胁而已，不敢动真的。</p><p>我不这样想。对崔永元这样的敢于揭露丑恶现象的英雄，我们不仅要大加称赞，更要倍加爱护。宁可把事情想得严重些，切不可掉以轻心。社会太需要这样的人了，他不能受到任何损害。</p><p>当然，我不认为影视界都是坏人，好人肯定还是多数。但是，少数坏人会做什么事，会不会有人铤而走险，谁敢打保票？</p><p>群众舆论的肯定，只是道义上的保护，不能代替具体的保护。</p><p>主管部门根据崔永元提供的线索，已经下发文件，采取了措施，并收到了立竿见影、大快人心的效果。这是对崔永元行为的支持，是这些部门应尽的职责。然而，即便如此，也不能代替具体的保护。</p><p>人身安全的责任，可能应该落实到公安系统。崔永元已经向公安机关报了案。这种自我保护意识，让我们看到了他的智慧。小崔说，有关派出所已经向上级做了汇报。我想，惩治坏人，保护好人，是我们公安部门的责任，这样的全国关注的大事，他们是不会掉以轻心的。</p><p>我们提倡“正能量”，但“正能量”是在和“负能量”的对抗中得以发挥的。所以，必须坚决支持和保护敢于向黑恶现象和势力做斗争的人。当我们的群众舆论、党和政府部门、公检法机关都来保护好人，那对坏人和丑恶现象就是最大震慑。</p><p>我们的法制建设应该跟上。我当全国政协委员的时候，就有过制定《舆论监督法》的提案。现在看，制定这样一个法律更显得必要。有了保护舆论监督者、举报者的法律，保护崔永元这样的好人，就会变得更加容易操作了。</p><p>本文作者艾丰，1938年4月5日生，高级记者，教授。曾任人民日报编委、经济部主任，经济日报总编辑。中国名牌战略最早倡导者之一，是公认的名牌理论权威专家。中国社科院研究生院、中国人民大学、北京财贸大学、中央民族学院等高等院校教授。现任中国工业经济联合会、中国质量协会副会长，中国名牌培育委员会主任，中国企业管理培训推进委员会主任。</p><p>崔永元：上大学新闻系教材就是艾丰先生的（新闻采访方法论）。艾丰先生教了我们采访没教我们避难。​​​​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​​原创： 艾丰  码字工匠老詹  今天&lt;/p&gt;
&lt;p&gt;在微信上看了崔永元的讲话视频和有关信息，知道他受到了人身安全威胁，一贯睡眠很好的我，竟然夜不能寐，失眠了。索性爬起来，写下这段文字。&lt;/p&gt;
&lt;p&gt;崔永元真的没有危险吗？&lt;/p&gt;
&lt;p&gt;到底由谁来保护崔永元？&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>崔永元：别再让孩子聪明伶俐地进去呆若木鸡地出来</title>
    <link href="http://ioext.com/2018/10/12/%E7%A4%BE%E4%BC%9A%E7%83%AD%E9%97%A8/%E5%B4%94%E6%B0%B8%E5%85%83%EF%BC%9A%E5%88%AB%E5%86%8D%E8%AE%A9%E5%AD%A9%E5%AD%90%E8%81%AA%E6%98%8E%E4%BC%B6%E4%BF%90%E5%9C%B0%E8%BF%9B%E5%8E%BB%E5%91%86%E8%8B%A5%E6%9C%A8%E9%B8%A1%E5%9C%B0%E5%87%BA%E6%9D%A5/"/>
    <id>http://ioext.com/2018/10/12/社会热门/崔永元：别再让孩子聪明伶俐地进去呆若木鸡地出来/</id>
    <published>2018-10-12T14:14:58.000Z</published>
    <updated>2018-11-07T03:36:21.419Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/public/static/images/社会热门/崔永元/别再让孩子聪明伶俐地进去呆若木鸡地出来/1.jpg" alt="Image text"><br>作者：崔 永 元</p><p>侄子在读高二，考了一道历史题：成吉思汗的继承人窝阔台，公元哪一年死？最远打到哪里？答不出来，我帮他查找资料，所以到现在我都记得，是打到现在的匈牙利附近？</p><p>在一次偶然的机会，我发现美国世界史这道题目不是这样考的？它的题目是这样的：成吉思汗的继承人窝阔台，当初如果没有死，欧洲会发生什么变化？试从经济、政治、社会三方面分析？</p><p>有个学生是这样回答的：这位蒙古领导人如果当初没有死，那么可怕的黑死病，就不会被带到欧洲去，后来才知道那个东西是老鼠身上的跳蚤引起的鼠疫。但是六百多年前，黑死病在欧洲猖獗的时候，谁晓得这个叫做鼠疫？如果没有黑死病，神父跟修女就不会死亡。神父跟修女如果没有死亡，就不会怀疑上帝的存在。如果没有怀疑上帝的存在，就不会有意大利弗罗伦斯的文艺复兴？</p><p>如果没有文艺复兴，西班牙、南欧就不会强大，西班牙无敌舰队就不可能建立。如果西班牙、意大利不够强大，盎格鲁—撒克逊会提早200年强大，日耳曼会控制中欧，奥匈帝国就不可能存在？</p><p>教师一看“棒，分析得好。”但他们没有分数，只有等级A。其实这种题目老师是没有标准答案的，可是大家都要思考。</p><p>不久前，我去了趟日本，日本总是和我们在历史问题上产生纠葛，所以我在日本很注意高中生的教科书？<br>他们的教师给高中生布置了这样一道题：日本跟中国100年打一次仗，19世纪打了日清战争（即甲午战争），20世纪打了一场日中战争（即抗日战争），21世纪如果日本跟中国开火，你认为大概是什么时候？可能的远因和近因在哪里？如果日本赢了，是赢在什么地方？输了是输在什么条件上？分析之？</p><p>其中有个高中生是这样分析的：我们跟中国很可能在台湾回到中国以后，有一场激战。台湾如果回到中国，中国会把基隆与高雄封锁，台湾海峡就会变成中国的内海，我们的油轮就统统走右边，走基隆和高雄的右边。这样，会增加日本的运油成本。我们的石油从波斯湾出来跨过印度洋，穿过马六甲海峡，上中国南海，跨台湾海峡进东海到日本海，这是石油生命线，中国政府如果把台湾海峡封锁起来，我们的货轮一定要从那里经过，我们的主力舰和驱逐舰就会出动，中国海军一看到日本出兵，马上就会上场，就开打！</p><p>按照判断，公元2015年至2020年之间，这场战争可能爆发。所以，我们现在就要做对华抗战的准备？</p><p>我看其他学生的判断，也都是中国跟日本的磨擦会从东海从台湾海峡开始，时间判断是 2015年至2020年之间？</p><p>这种题目和答案都太可怕了。</p><p>撇开政治因素来看这道题，我们的历史教育就很有问题。翻开我们的教科书，题目是这样出的：甲午战争是哪一年爆发的？签订的叫什么条约？割让多少土地？赔偿多少银两？？每个学生都努力做答案。结果我们一天到晚研究什么时候割让辽东半岛，什么时候丢了台湾、澎湖、赔偿二万银两，1894年爆发甲午战争、1895 年签订马关条约，背得滚瓜烂熟，都是一大堆枯燥无味的数字。</p><p>那又怎么样，反正都赔了嘛！银两都给了嘛！最主要的是将来可能会怎样！</p><p>人家是在培养能力，而我们是在灌输知识，这是值得深思的部份！</p><p>看外面的教育，再看我们的教育？</p><p>老妈去参加我侄子的家长会，带回了两套侄子的考试试卷，我很好奇，拿过来看了现在小学生的试卷后，我震惊了！这是什么狗屁教育？这样的教育有希望吗？？下面给大家详细说说我看到了什么？</p><p>侄子在本市某著名小学读书，有这么几道题。</p><p>一个春天的夜晚，一个久别家乡的人，望着皎洁的月光不禁思念起了故乡，于是吟起了一首诗：（），（）？</p><p>我看到侄子答的是：举头望明月，低头思故乡。但后面是一把大大的X，我就奇怪了，我也是想到的这2句。好奇的问侄子，这个不对？？那答案是什么？侄子说标准答案是：春风又绿江南岸，明月何时照我还？哎，这就奇怪了，因为是个春天的夜晚，就要是这句有春风的？？？要这个思念故乡的人不是江南的，是不可能说出春风又绿江南岸这句话的！！！举头望明月，低头思故乡应该更准确。再扯远点，思念故乡，一千个人可以吟一千句不一样的诗，这个也可以有标准答案的么？</p><p>接下来是默写，题目是：我们学过《桂林山水》一文，请将下面句子默写下来，然后就是整段的要默写，这有什么用？死记硬背别人的文字有什么用？</p><p>还有个题目，《匆匆》这篇课文，是现代著名作家朱自清先生写的，同学们都很喜欢这篇散文，你能把自己最喜欢，印象最深刻的一句写下来吗？我侄子写的是：我的日子滴在时间的流里，没有声音，也没有影子。后面一把好大的X。标准答案竟然是：但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？这就更奇怪了，一篇文章，你可以喜欢这句，我可以喜欢那句，难道最喜欢的一句话也要统一么？为什么“我的日子滴在时间的流里，没有声音，也没有影子。”这句不能喜欢？就一定要喜欢“但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？”这句？？？我觉得这个题目应该是“你能把老师最喜欢，印象最深刻的一句写下来吗？”才对！？</p><p>再看别的试卷，更莫名其妙了，比如请说出阿拉伯数字的来历，是哪个国家创造的？侄子不知道，问我，我也不知道。我只好去搜一下，才知道是古印度人发明的。莫非我吃块猪肉，还一定得知道它是哪个养猪场养出来的？</p><p>最后有个题目让我彻底崩溃了：请用一句话说明π的含义。侄子回答π的含义是圆周率。竟然打的是X，这就奇怪了，正好我老婆大学说读的是理科，我马上问她，π是什么意思，她说圆周率啊。两个人狂汗，问了侄子半天，标准答案大概是，π是一个在数学及物理学领域普遍存在的数学常数……</p><p>如果你也觉得这种教育很无耻，就请转发吧，让更多的人来参与呼吁改变，为了孩子为了国家的未来……别让孩子聪明伶俐地进去呆若木鸡地出来！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/public/static/images/社会热门/崔永元/别再让孩子聪明伶俐地进去呆若木鸡地出来/1.jpg&quot; alt=&quot;Image text&quot;&gt;&lt;br&gt;作者：崔 永 元&lt;/p&gt;
&lt;p&gt;侄子在读高二，考了一道历史题：成吉思汗的继承人窝阔台，公元哪一年
      
    
    </summary>
    
      <category term="崔永远" scheme="http://ioext.com/categories/%E5%B4%94%E6%B0%B8%E8%BF%9C/"/>
    
      <category term="热门" scheme="http://ioext.com/categories/%E5%B4%94%E6%B0%B8%E8%BF%9C/%E7%83%AD%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>崔永元:举报北京朝阳分局新源里派出所</title>
    <link href="http://ioext.com/2018/10/11/%E7%A4%BE%E4%BC%9A%E7%83%AD%E9%97%A8/%E5%B4%94%E6%B0%B8%E5%85%83:%20%E4%B8%BE%E6%8A%A5%E5%8C%97%E4%BA%AC%E6%9C%9D%E9%98%B3%E5%88%86%E5%B1%80%E6%96%B0%E6%BA%90%E9%87%8C%E6%B4%BE%E5%87%BA%E6%89%80/"/>
    <id>http://ioext.com/2018/10/11/社会热门/崔永元: 举报北京朝阳分局新源里派出所/</id>
    <published>2018-10-11T11:41:18.000Z</published>
    <updated>2018-10-15T02:49:50.066Z</updated>
    
    <content type="html"><![CDATA[<p>关于对北京朝阳分局新源里派出所执法敷衍不作为的举报与抗议</p><p>举  报 人：中国传媒大学教授 崔永元</p><p>被 举 报 人：北京市公安局朝阳分局新源里派出所</p><p>负   责  人：槐  杰      所  长</p><p>住       址：北京市朝阳区新源里17号</p><p>电       话：010-64674294</p><p>致北京市公安局警务督察总队：</p><p>自2013年起，本人因反对转基因滥种、揭发范冰冰冯小刚华谊兄弟偷逃税等义举，遭到相关利益集团和水军的无耻漫骂诬蔑污辱。直至发展到赤祼裸地人身安全受到威胁。留学海外的女儿信息被公开，安全无保障。本人为中华人民共和国公民，相信法律机关，相信法律公平公正。相继向公安机关报䅁：退役军人徐勇凌威胁鼓动杀人案、黄毅清严重侵犯隐私案、黄毅清诬告陷害案等刑事案件及新近发生的网民“老369”严重诽谤案。到目前为止，只有退役军人徐勇凌威胁杀人案以警局调解我善意原谅做了了结。而反映的其他问题迟迟未予答复、立案受理，违法犯罪嫌疑人黄毅清、“老369”等居然以天为单位每天污辱诽谤威胁。特别提醒警方是每一天。我想，这样的心理压力和思想压力绝大部份正常人都无法承受。但是新源里派出所和相关干警很能承受，嘴巴说得热闹，像哄孙子一样。</p><p>具体事实如下：</p><p>1、 举报人报案案情介绍</p><p>（一）徐勇凌恐吓、威胁案</p><p>举报人是新浪微博实名认证用户“崔永元”的使用者，自2018年5月下旬起，举报人因揭露娱乐圈明星阴阳合同、天价报酬、逃税偷税等一系列问题，引起了社会的广泛关注。</p><p>徐勇凌为新浪微博实名认证用户“徐勇凌”（改名之前昵称为“国际试飞员徐勇凌”）、“徐勇凌先生”的使用者。2018年6月起，徐勇凌通过“国际试飞员徐勇凌”账户，多次发布威胁、辱骂举报人的微博内容，带有“崔阳寿不多了”、“和我斗，黑道白道都不是个”、“人人可击毙疯狗崔永元”等字眼，恐吓、威胁、侮辱举报人。</p><p>我报案后，新源里派出所干警出面调解。其实徐勇凌行为已构成犯罪，但考虑到他是退伍军人会影响部队形象，本人认可了调解。2018年8月3日，徐勇凌通过“徐勇凌先生”账号公开向我致歉，但仅仅过了一天就将此致歉信删除。经本人查询，徐勇凌威胁、辱骂举报人的账户“国际试飞员徐勇凌”拥有550万粉丝数，而其道歉的“徐勇凌先生”只有粉丝数88人。通过如此低劣的阳奉阴违的手段，可见徐勇凌道歉的态度毫无诚意。很快，徐勇凌又继续于2018年8月31日通过“徐勇凌”账户发布相关辱骂内容，不是第二次，而是第二轮。</p><p>（二）黄毅清泄露隐私、诬告陷害、寻衅滋事案</p><p>黄毅清为新浪微博实名认证用户“AndyHYQ”、“黄·毅清”的使用者，自2018年6月18日起，黄毅清开始在其实名认证的微博账户“AndyHYQ”、“黄·毅清”连续发表多篇微博，捏造我联手红通人员施建祥诈骗上海百姓钱款，还捏造我协助施建祥外逃。(相关诽谤证据附后），后又捏造我有四个情人和一个私生子等不实内容（相关诽谤证据附后），除此之外，黄毅清在2018年9月8日故意曝光了我女儿的姓名、照片、留学城市等隐私信息。这严重扰乱本人和无辜受牵连的其他人的正常生活，被无辜拖累女士不堪污辱身心疲惫，有的患心脏病抑郁症，有的甚至萌生了自杀的念头。2018年9月11日，黄毅清自知闯大祸已难以收场，竟然耍苦肉计捏造我对其下毒造成他中毒昏迷经医生抢救脱险的不实内容，并称已向有关部门报案，这是十足的诬告陷害。</p><p>黄毅清是拥有350余万粉丝的网络大V级别的微博用户，始终如幽灵一般缠着我和家人、友人。每天都发送侮辱、诽谤本人、本人家人、本人友人的微博内容。黄毅清手段低级下流，每次发布内容后不久即删除相关内容，这也是他发明的逃避手段一一让受害人来不及公证证据。但每次都会形成大量转发。许多不明真相的围观群众因此对本人误解并参与谩骂、侮辱。做为当事人，本人无比愤怒多次失去理智。但思来想去也只能压制仇恨情绪，依法办事，做合格公民。黄毅清的行为已触犯刑法规定，构成刑事犯罪，理应依法追究刑事责任。</p><p>（三）“老369”诽谤、侮辱案</p><p>自2018年8月18日起，新浪微博用户“老369”通过其微博账户，发布关于我的不实图文信息。一是重复黄毅清恶意诽谤我与红通犯共同犯罪的所谓内情二是婚外情和私生子的虚假事实。文中大量使用“精神病患者”、“流氓”、“叫兽”、“骗子”、“疯”等下流、低俗的词汇辱骂举报人，甚至以举报人妻子及女儿的口吻发布了文章《我的精神病丈夫》、《我的精神病爸爸》侮辱、嘲讽举报人。“老369”的行为依治安管理处罚法，应依法对其实施行政处罚。</p><p>二、公安机关不作为的恶劣事实</p><p>针对徐勇凌、黄毅清及“老369”的前述违法犯罪事实，本人和本人委派的律师分别于2018年7月、2018年9月10日、2018年9月12日、2018年9月19日和2018年9月26日等多次到管理本人住所地的新源里派出所报案，并将相关证据提交给了办案人员。</p><p>本人压力重重已经两次重病住院却自始至终遵法守法，坚持通过正当法律途径维权，始终对法律充满信心。</p><p>令人没有想到的是，新源里派出所乃至朝阳分局对本人举报的这些案件无所用心消极应对。如，每次去报案，办案人员均以要请示上级为由让等待，最长一次等待5个多小时才做笔录。在笔录过程中，发现警员对网络环境非常陌生，跟他们描述个事情要费吃奶的劲儿，还时常表现出不耐烦。此外，每次询问案件进展时，均被以各种借口打发、拖延。其中一名承办民警房子豪甚至宣称去了上海“找不到黄毅清”。你们能不能稍微有点职业感？一名警察这样描述自己的工作不觉得像个饭桶？顺便讲个笑话，我在海淀法院刑事自诉黄毅清，海淀法院也说找不到。我能不能告诉你们，我找得到，很容易，我找来交给你们好不好？</p><p>根据《公安部关于改革完善受案立案制度的意见》规定，刑事案件立案审查期限原则上不超过3日；涉嫌犯罪线索需要查证的，立案审查期限不超过7日；重大疑难复杂案件，经县级以上公安机关负责人批准，立案审查期限可以延长至30日。请问，你们想用多少日？</p><p>这就是执法为民？我认为，徐勇凌黄毅清之所以在网络上这样流氓这样猖狂和你们的呵护是分不开的。徐犯罪了，你们鼓励我宽容，黄犯罪了，你们找不着，让他大摇大摆随意作恶。一个公民，人身安全没保障，他的女儿，人身安全受威胁，他的朋友无辜受辱以泪洗面……在你们眼里你们心里无足轻重。曾经警局告诉我：你是名人，是大学教授，是政协委员，所以上级领导很重视。请你们描述一下以上作为哪个算重视？退一万步讲，我这个算重视，老百姓就真是告状无门忍气吞声地活着。</p><p>三、我的请求</p><p>恳请贵部门查明本案事实，督促北京市公安局朝阳分局及新源里派出所尽快进行立案审查，还守法公民以公道，装也要装出积极作为的样子，给中国法律一点面子。</p><p>不要认为自己手里有点权利就可以随心所欲。有一天，你们也会希望得到法律的救援、希望社会正义、希望家人幸福平安，当你面对的是像你们一样素质的执法者，你们也会绝望。这样事情发生的概率不会低。</p><p>守法公民对社会绝望被逼上梁山者古以有之，守法公民被迫以违法方式维护自己尊严的更是不鲜见。那是黄毅清们狗娘养的犯罪分子逼的，也是你们这些手握公权力坚持不作为的执法机构逼的。</p><p>公民崔永元向你们表示严正抗议！</p><p>本文将同时刊登在海外媒体上。</p><p>举报人：崔永元</p><p>2018年   10月   10日</p><p>附：</p><p>1.受案回执：2018年9月10日 京公朝（新）受案字[2018]000432号</p><p>2.受案回执：2018年9月12日 京公朝（新）受案字[2018]000434号</p><p>3.受案回执：2018年9月26日 京公朝（新）受案字[2018]000469号</p><p>4.受案登记表：2018年9月26日 京公朝（新）受案字[2018]000469号​​​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于对北京朝阳分局新源里派出所执法敷衍不作为的举报与抗议&lt;/p&gt;
&lt;p&gt;举  报 人：中国传媒大学教授 崔永元&lt;/p&gt;
&lt;p&gt;被 举 报 人：北京市公安局朝阳分局新源里派出所&lt;/p&gt;
&lt;p&gt;负   责  人：槐  杰      所  长&lt;/p&gt;
&lt;p&gt;住       址：北
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>可以管理时间的二叉堆</title>
    <link href="http://ioext.com/2017/12/14/%E7%AE%97%E6%B3%95/%E5%8F%AF%E4%BB%A5%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4%E7%9A%84%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>http://ioext.com/2017/12/14/算法/可以管理时间的二叉堆/</id>
    <published>2017-12-13T16:28:24.000Z</published>
    <updated>2018-11-07T03:36:21.423Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面试官：写一个堆排吧<br>我心想：堆排是什么鬼😳</p></blockquote><p>理解堆排，首先要理解二叉堆。理解了二叉堆的“下沉”操作，基本上就可以理解堆排了。今天我们来看一看什么是堆，以及堆的一般操作</p><h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><blockquote><p>近日，谦子遇到了烦心事，于是找老师去诉苦了</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/1.jpeg" alt=""></p><blockquote><p>谦子列了几个要做的事</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/2.jpeg" alt="">  </p><blockquote><p>谦子道出了心中的苦  </p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/3.jpeg" alt="">   </p><blockquote><p>谦子两眼发光</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/4.jpeg" alt=""></p><blockquote><p>克顺手画了一个图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/5.jpeg" alt=""></p><ul><li>优先级队列中每个元素都有优先级</li><li>优先级最高的最先被处理</li></ul><h1 id="优先级队列的实现"><a href="#优先级队列的实现" class="headerlink" title="优先级队列的实现"></a>优先级队列的实现</h1><p><img src="/public/static/images/算法/可以管理时间的二叉堆/6.jpeg" alt=""> </p><blockquote><p>谦子非常想知道黑盒里面是什么  </p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/7.jpeg" alt=""> </p><blockquote><p>克非常善于引导学生思考</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/8.jpeg" alt=""> </p><blockquote><p>谦子想了想说</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/9.jpeg" alt=""> </p><blockquote><p>谦子说着说着画了一个图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/10.jpeg" alt=""></p><blockquote><p>谦子画了一幅图解释道</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/11.jpeg" alt=""></p><blockquote><p>随后，谦子又画出了插入6后的图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/12.jpeg" alt=""></p><blockquote><p>克还是不满意</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/13.jpeg" alt=""></p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><img src="/public/static/images/算法/可以管理时间的二叉堆/14.jpeg" alt=""></p><ul><li>这里我们只讨论二叉堆，把二叉堆称为堆</li><li>堆也有d-堆，左式堆等等</li></ul><p><img src="/public/static/images/算法/可以管理时间的二叉堆/15.jpeg" alt=""></p><blockquote><p>克看谦子不是很明白，顺手画了个图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/16.jpeg" alt=""></p><blockquote><p>克画了一个二叉堆实例</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/17.jpeg" alt=""></p><blockquote><p>注意: 二叉堆中两个孩子之前的大小没有关系，可能左孩子&gt;=右孩子，也可能右&gt;=左</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/18.jpeg" alt=""></p><blockquote><p>克随手画了一个小根堆和一个大根堆</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/19.jpeg" alt=""></p><blockquote><p>本文讨论小根堆</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/20.jpeg" alt=""></p><p><img src="/public/static/images/算法/可以管理时间的二叉堆/21.jpeg" alt=""></p><h1 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h1><p><img src="/public/static/images/算法/可以管理时间的二叉堆/22.jpeg" alt=""></p><ul><li>每个父节点的值小于等于其左右孩子的值被称为堆的有序性</li><li>另一种情况是大于等于也称之为堆的有序性</li></ul><blockquote><p>克随手画了一个插入操作破坏堆有序性的图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/23.jpeg" alt=""></p><blockquote><p>如何调整，谦子心里想</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/24.jpeg" alt=""></p><blockquote><p>上浮这个词形象生动，谦子心里想</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/25.jpeg" alt=""></p><blockquote><p>说完，克飞速地写出了上浮的代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  如果待插入的元素小于其父,则交换子和父,并继续上浮,知道大于等于其父</span><br><span class="line"> *  @param arr 存储堆的数组,元素从下标 1 开始有效, 0 位置不存有效值</span><br><span class="line"> *  @param inserted 被插入节点的索引</span><br><span class="line">*/</span><br><span class="line">public void swim(int[] arr, int inserted)</span><br><span class="line">&#123;</span><br><span class="line">    int parent = inserted/2; // 求出带插入元素父节点的索引</span><br><span class="line">    if( arr[inserted] &lt; arr[parent] )</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr,inserted,parent); //交换arr[inserted]和arr[parent]</span><br><span class="line">        swim(arr,parent);//交换后继续上浮</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>谦子暗自惊叹老师的代码功力</p></blockquote><h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><p><img src="/public/static/images/算法/可以管理时间的二叉堆/26.jpeg" alt=""></p><blockquote><p>谦子听完此话紧张的手心出汗，但还是硬着头皮想了想，突然灵光一现</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/27.jpeg" alt=""></p><blockquote><p>随后谦子画出了交换后的图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/28.jpeg" alt=""><br><img src="/public/static/images/算法/可以管理时间的二叉堆/29.jpeg" alt=""><br><img src="/public/static/images/算法/可以管理时间的二叉堆/30.jpeg" alt=""><br><img src="/public/static/images/算法/可以管理时间的二叉堆/31.jpeg" alt=""></p><blockquote><p>谦子刚松了口气，谁知还要写代码，只见谦子想了想，写写擦擦好几遍最终写下了如下代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  对以arr[parentIndex]为父节点的堆进行调整(下沉)</span><br><span class="line"> *  在父节点、左右孩子中选出最小节点,如果最小节点不是父节点则交换</span><br><span class="line"> *  继续下沉,反之不下沉</span><br><span class="line"> *  @param arr 要调整的数组</span><br><span class="line"> *  @param parentIndex 父节点的索引</span><br><span class="line">*/</span><br><span class="line">private void sink(int[] arr, int parentIndex)</span><br><span class="line">&#123;</span><br><span class="line">    //堆的大小,第0个位置无效元素</span><br><span class="line">    int heapSize = arr.length-1;</span><br><span class="line">    //从父节点、左孩子和右孩子中选出最小节点,得其索引</span><br><span class="line">    int minNodeIndex = minIndex(arr,parentIndex,heapSize);</span><br><span class="line">    //如果最小节点的索引不是父节点,则说明最小节点在左右孩子中,交换并继续下沉</span><br><span class="line">    if( minNodeIndex != parentIndex )</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr,minNodeIndex,parentIndex);</span><br><span class="line">        sink(arr,minModeIndex);//交换后继续下沉</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/public/static/images/算法/可以管理时间的二叉堆/32.jpeg" alt=""></p><blockquote><p>谦子解释道，并画了一个图</p></blockquote><p><img src="/public/static/images/算法/可以管理时间的二叉堆/33.jpeg" alt=""></p><blockquote><p>只见谦子又写了一段代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  求得给定的三个节点的最小节点的索引</span><br><span class="line"> *  @param parentIndex 父节点的索引</span><br><span class="line"> *  @param heapSize 堆的大小</span><br><span class="line"> *  @return 最小节点的索引</span><br><span class="line">*/</span><br><span class="line">private int minIndex(int[] arr,int parentIndex,int heapSize)</span><br><span class="line">&#123;</span><br><span class="line">    int minIndex = parentIndex;//保存最小节点的下标,初始时认为父节点最小</span><br><span class="line">    int leftIndex = leftIndex(parentIndex);//找到parentIndex的左孩子下标</span><br><span class="line">    //如果leftIndex没有越界,比较左孩子和父节点,选较小的Node的下标赋给minIndex</span><br><span class="line">    if(leftIndex &lt;= heapSize)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = arr[leftIndex] &lt; arr[parentIndex] ? leftIndex : parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    int rightIndex = rightIndex(parentIndex);</span><br><span class="line">    if( rightIndex &lt;= heapSize)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = arr[rightIndex] &lt; arr[minIndex] ? rightIndex : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    return minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>leftIndex = 2*parentIndex;</li><li>rightIndex = 2*parentIndex+1;</li></ul><p><img src="/public/static/images/算法/可以管理时间的二叉堆/34.jpeg" alt=""></p><blockquote><p>看来以后得好好学数据结构与算法了，不然连时间都管理不好，谦子心想</p></blockquote><ul><li>此文章转载<a href="https://mp.weixin.qq.com/s/XEuLlIUnlBpMJPM_ipWptA" target="_blank" rel="noopener">可以管理时间的二叉堆.涛声依旧</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面试官：写一个堆排吧&lt;br&gt;我心想：堆排是什么鬼😳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解堆排，首先要理解二叉堆。理解了二叉堆的“下沉”操作，基本上就可以理解堆排了。今天我们来看一看什么是堆，以及堆的一般操作&lt;/p&gt;
&lt;h1 id=&quot;优先
      
    
    </summary>
    
    
      <category term="二叉堆" scheme="http://ioext.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
      <category term="堆" scheme="http://ioext.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用的数据类型以及转换函数</title>
    <link href="http://ioext.com/2017/12/11/mysql/Mysql%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <id>http://ioext.com/2017/12/11/mysql/Mysql常用的数据类型以及转换函数/</id>
    <published>2017-12-11T10:32:42.000Z</published>
    <updated>2017-12-11T02:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用的数据类型"><a href="#一、常用的数据类型" class="headerlink" title="一、常用的数据类型"></a>一、常用的数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><blockquote><p>int类型分类<br>1、 tinyint   1字节<br>2、 smallint  2字节<br>3、 mediumint 3字节<br>4、 int       4字节<br>5、 bigint    8字节</p></blockquote><blockquote><p>float 浮点数<br>  double 双精度<br>decimal 可以指定小数位  decimal(总长度，小数位长度) </p></blockquote><h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2><blockquote><p>date      日期类型<br>  datetime   日期类型<br>timestamp  时间戳  </p></blockquote><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><blockquote><p>char      不可变长度的字符串<br>  varchar   可变字符串字符串 最大长度 21845<br>text      大文本类型  长度无限制</p></blockquote><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><blockquote><p>blob    二进制流类型<br>enum 枚举 插入值时 对应的值 必须在枚举中存在</p></blockquote><h1 id="二、常用的数据库函数"><a href="#二、常用的数据库函数" class="headerlink" title="二、常用的数据库函数"></a>二、常用的数据库函数</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><blockquote><p>  CHARSET(str) //返回字串字符集<br>    CONCAT (string2 [,… ]) //连接字串<br>    INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0<br>    LCASE (string2 ) //转换成小写 oracle lower(字符串)<br>    UCase（string） //转换为大写  oracle upper(字符串)<br>    LEFT (string2 ,length ) //从string2中的左边起取length个字符 等价于  SUBSTRING(字符串,1,length);<br>    SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,<br>    LENGTH (string ) //string长度<br>    LTRIM (string2 ) //去除前端空格<br>    RTRIM (string2 ) //去除后端空格<br>    STRCMP (string1 ,string2 ) //逐字符比较两字串大小,<br>  REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_str</p></blockquote><h3 id="不经常使用"><a href="#不经常使用" class="headerlink" title="不经常使用"></a>不经常使用</h3><blockquote><p>  LOAD_FILE (file_name ) //从文件读取内容 例如 load_file(全路径);<br>    LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置  找到第一个字符串在第二个字符串的位置<br>    LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为length<br>    RPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为length<br>    REPEAT (string2 ,count ) //重复count次<br>    comress(string) 对字符串进行<br>uncomress(被压缩的字符串) 对字符串进行解压缩</p></blockquote><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><blockquote><p>ABS (number2 ) //绝对值<br>     FLOOR (number2 ) //向下取整 只保留整数位  不会四舍五入<br>     CEILING (number2 ) //向上取整 只要小数位大于0的值  整数位都进1<br>     ROUND (number [,decimals ]) //四舍五入,decimals为小数位数]<br>     FORMAT (number,decimal_places ) //保留小数位数 第二个参数是必选的<br>     RAND([seed]) //随机数<br>     MOD (numerator ,denominator ) //求余 等价于 数字%数字<br>     –不经常使用<br>     BIN (decimal_number ) //十进制转二进制<br>     CONV(number2,from_base,to_base) //进制转换<br>     HEX (DecimalNumber ) //转十六进制<br>     注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143<br>     也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19<br>     LEAST (number , number2 [,..]) //求最小值<br>POWER (number ,power ) //求指数</p></blockquote><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><blockquote><p> NOW ( ) //当前时间<br> CURRENT_DATE ( ) //当前日期  缩写 curdate()<br> CURRENT_TIME ( ) //当前时间  缩写 curtime()<br> CURRENT_TIMESTAMP ( ) //当前时间戳 定位到某一个时间点<br> //添加时间  第二个参数参数为1个值时 添加秒  参数为 时间:时间  添加小时和分钟<br> ADDTIME (date2 ,time_interval ) //将time_interval加到date2  用来<br> //formatCode的格式为  select date_format(now(),’%Y-%m-%d %H:%i:%s’);<br> DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetime<br>DATEDIFF (date1 ,date2 ) //两个日期差  结果是天数</p></blockquote><h3 id="不经常使用-1"><a href="#不经常使用-1" class="headerlink" title="不经常使用"></a>不经常使用</h3><blockquote><p>CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区<br>    DATE (datetime ) //返回datetime的日期部分<br>    DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间<br>    DATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间<br>    DAY (date ) //返回日期的天<br>    DAYNAME (date ) //英文星期<br>    DAYOFWEEK (date ) //星期(1-7) ,1为星期天<br>    DAYOFYEAR (date ) //一年中的第几天<br>    EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分<br>    MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串<br>    MAKETIME (hour ,minute ,second ) //生成时间串<br>    MONTHNAME (date ) //英文月份名<br>    SEC_TO_TIME (seconds ) //秒数转成时间<br>    STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示<br>    TIMEDIFF (datetime1 ,datetime2 ) //两个时间差<br>    TIME_TO_SEC (time ) //时间转秒数]<br>    WEEK (date_time [,start_of_week ]) //第几周<br>    YEAR (datetime ) //年份<br>    DAYOFMONTH(datetime) //月的第几天<br>    HOUR(datetime) //小时<br>    LAST_DAY(date) //date的月的最后日期<br>    MICROSECOND(datetime) //微秒<br>    MONTH(datetime) //月<br>    MINUTE(datetime) //分返回符号,正负或0<br>SQRT(number2) //开平方</p></blockquote><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><blockquote><p>convert(expression,type)<br>  select convert(now(),char);<br>cast(expression as type) 转换类型  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、常用的数据类型&quot;&gt;&lt;a href=&quot;#一、常用的数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、常用的数据类型&quot;&gt;&lt;/a&gt;一、常用的数据类型&lt;/h1&gt;&lt;h2 id=&quot;数字类型&quot;&gt;&lt;a href=&quot;#数字类型&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://ioext.com/tags/mysql/"/>
    
      <category term="数据类型装换" scheme="http://ioext.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A3%85%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法--插入排序改进--二分插入排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法/算法-插入排序改进-二分插入排序/</id>
    <published>2017-12-07T17:36:08.000Z</published>
    <updated>2017-12-07T10:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function InsertionSortDichotomy($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $n = count($arr);</span><br><span class="line">    for ($i=1; $i &lt; $n ; $i++) </span><br><span class="line">    &#123; </span><br><span class="line">       $get = $arr[$i];         //右手抓到一张扑克</span><br><span class="line">       $left = 0;               // 拿在左手上的牌总是排序好的，所以可以用二分法</span><br><span class="line">       $right = $i - 1;         //手牌左右边界进行出初始化</span><br><span class="line"></span><br><span class="line">       while ( $left &lt;= $right) </span><br><span class="line">       &#123;</span><br><span class="line">           $mid =floor(($left+$right) / 2);</span><br><span class="line">           if( $arr[ $mid ] &gt; $get )</span><br><span class="line">           &#123;</span><br><span class="line">                $right = $mid - 1;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">                $left = $mid + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for ($j=$i-1; $j &gt;= $left ; $j--) //将欲插入的新牌的位置右边的牌整体向右移动一个单位</span><br><span class="line">       &#123; </span><br><span class="line">           $arr[$j+1] = $arr[$j];</span><br><span class="line">       &#125;</span><br><span class="line">       $arr[$left] = $get;              //将抓到的牌插入手牌</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分插入排序&quot;&gt;&lt;a href=&quot;#二分插入排序&quot; class=&quot;headerlink&quot; title=&quot;二分插入排序&quot;&gt;&lt;/a&gt;二分插入排序&lt;/h1&gt;&lt;p&gt;对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="http://ioext.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="二分插入排序" scheme="http://ioext.com/tags/%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--插入排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法/算法-插入排序/</id>
    <published>2017-12-07T17:18:21.000Z</published>
    <updated>2018-11-07T03:38:52.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌</p></blockquote><p><img src="/public/static/images/算法/插入排序/1.jpg" alt=""></p><p>对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入  </p><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间  </p><h3 id="具体算法描述如下"><a href="#具体算法描述如下" class="headerlink" title="具体算法描述如下:"></a>具体算法描述如下:</h3><blockquote><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5  </li></ol></blockquote><p>插入排序的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function InsertionSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $n = count( $arr );</span><br><span class="line">    for ($i=1; $i &lt; $n; $i++)   //类似抓扑克牌排序</span><br><span class="line">    &#123; </span><br><span class="line">        $get = $arr[$i];        //右手抓到一张扑克牌</span><br><span class="line">        $j = $i-1;              //拿在左手上的牌总是排序好的</span><br><span class="line">        while( $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $get )//将抓到的牌与手牌从右向左进行比较</span><br><span class="line">        &#123;</span><br><span class="line">            $arr[ $j+1 ] = $arr[$j];//如果该手牌比抓到的牌大，就将其右移</span><br><span class="line">            $j --;</span><br><span class="line">        &#125;</span><br><span class="line">        $arr[$j+1] = $get;      //直到该手牌比抓到的牌小(或者二者相等)，将抓到的牌插入到该手牌的右边(相等元素的相对次序未变，所以插入排序是稳定的)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下</p><p><img src="/public/static/images/算法/插入排序/2.gif" alt=""></p><p>使用插入排序为一列数字进行排序的宏观过程:</p><p><img src="/public/static/images/算法/插入排序/3.gif" alt=""></p><blockquote><p>注意:插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="http://ioext.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--选择排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法/算法-选择排序/</id>
    <published>2017-12-07T16:47:47.000Z</published>
    <updated>2018-11-07T03:38:52.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：</p><blockquote><p>1、初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列； </p></blockquote><blockquote><p>2、然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</p></blockquote><blockquote><p>3、以此类推，直到所有元素均排序完毕</p></blockquote><p>注意选择排序与冒泡排序的区别：</p><blockquote><p>1、冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；</p></blockquote><blockquote><p>2、而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function SelectionSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $n = count( $arr );</span><br><span class="line">    //此循环控制走的次数</span><br><span class="line">    //此循环用来控制每一次要从中找到最大值的数据的个数</span><br><span class="line">    //也可以理解为下标范围：从0到$n-$i-1</span><br><span class="line">    //接下来，要从0到$n-$i-1范围内找到最大的那个</span><br><span class="line">    for ($i =0; $i &lt; $n-1; $i ++) </span><br><span class="line">    &#123; </span><br><span class="line">        //用于存储最大值</span><br><span class="line">       $max = $arr[0];</span><br><span class="line">       //用于存储最大值的下标，初始化为第一的下标</span><br><span class="line">       $max_pos = 0;</span><br><span class="line"></span><br><span class="line">       for ($k =0; $k &lt; $n-$i ; $k ++) </span><br><span class="line">       &#123; </span><br><span class="line">           if( $arr[$k] &gt; $max )</span><br><span class="line">           &#123;</span><br><span class="line">                $max = $arr[$k];</span><br><span class="line">                $max_pos = $k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //以上找到最大值的位置 $max_pos</span><br><span class="line">       //也就是说，这些单元中的最后一个单元的位置是 $n-$i-1</span><br><span class="line">       $tmp = $arr[$max_pos];</span><br><span class="line">       $arr[$max_pos] = $arr[$n-$i-1];</span><br><span class="line">       $arr[$n-$i-1] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SelectionSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $n = count( $arr );</span><br><span class="line">    //i为已排序序列的末尾</span><br><span class="line">    for ($i =0; $i &lt; $n-1; $i ++) </span><br><span class="line">    &#123; </span><br><span class="line">       $min = $i;</span><br><span class="line">       //未排序序列</span><br><span class="line">       for ($j= $i+1 ; $j &lt; $n; $j++) </span><br><span class="line">       &#123; </span><br><span class="line">            //找到为排序序列的最小值</span><br><span class="line">           if( $arr[$j] &lt; $arr[$min] )</span><br><span class="line">           &#123;</span><br><span class="line">                $min = $j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if( $min != $i )</span><br><span class="line">       &#123;</span><br><span class="line">            $tmp = $arr[$i];</span><br><span class="line">            $arr[$i] = $arr[$min];</span><br><span class="line">            $arr[$min] = $tmp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码对序列[ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 ]进行选择排序的实现过程如图</p><p><img src="/public/static/images/算法/选择排序/1.gif" alt=""></p><p>使用选择排序为一列数字进行排序的宏观过程:</p><p><img src="/public/static/images/算法/选择排序/2.gif" alt=""></p><blockquote><p>选择排序是不稳定的排序算法，不稳定发生在最小元素与$arr[i]交换的时刻<br>比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;p&gt;选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、初始时在序列中找到
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="选择排序" scheme="http://ioext.com/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--冒泡排序改进--鸡尾酒排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B-%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法/算法-冒泡排序改进-鸡尾酒排序/</id>
    <published>2017-12-07T16:29:35.000Z</published>
    <updated>2018-11-07T03:38:52.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h1><p>鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function BubbleSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $left = 0;                //初始化边界</span><br><span class="line">    $right = count( $arr )-1;</span><br><span class="line">    while( $left &lt; $right )</span><br><span class="line">    &#123;</span><br><span class="line">        //前半轮，将最大元素放到后面</span><br><span class="line">        for ($i=$left; $i &lt; $right ; $i++)  </span><br><span class="line">        &#123; </span><br><span class="line">            if( $arr[$i] &gt; $arr[$i+1] )</span><br><span class="line">            &#123;</span><br><span class="line">                $tmp = $arr[$i+1];</span><br><span class="line">                $arr[ $i+1 ] = $arr[$i];</span><br><span class="line">                $arr[ $i ] = $tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $right --;</span><br><span class="line"></span><br><span class="line">        // 后半轮,将最小元素放到前面</span><br><span class="line">        for ($i=$right; $i &gt; $left ; $i--) </span><br><span class="line">        &#123; </span><br><span class="line">            if( $arr[ $i-1 ] &gt; $arr[$i] )</span><br><span class="line">            &#123;</span><br><span class="line">                $tmps = $arr[ $i-1 ];</span><br><span class="line">                $arr[$i-1] = $arr[$i];</span><br><span class="line">                $arr[$i] = $tmps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $left++;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用鸡尾酒排序为一列数字进行排序的过程如下图所示:</p><p><img src="/public/static/images/算法/冒泡排序-鸡尾酒排序/1.gif" alt=""></p><blockquote><p>注意: 以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;鸡尾酒排序&quot;&gt;&lt;a href=&quot;#鸡尾酒排序&quot; class=&quot;headerlink&quot; title=&quot;鸡尾酒排序&quot;&gt;&lt;/a&gt;鸡尾酒排序&lt;/h1&gt;&lt;p&gt;鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="冒泡排序" scheme="http://ioext.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="鸡尾酒排序" scheme="http://ioext.com/tags/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--冒泡排序</title>
    <link href="http://ioext.com/2017/12/07/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/07/算法/算法-冒泡排序/</id>
    <published>2017-12-07T15:57:01.000Z</published>
    <updated>2018-11-07T03:38:52.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。  </p></blockquote><blockquote><p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function BubbleSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    //设置一个空数组 用来接收冒出来的泡</span><br><span class="line">    //该层循环控制 需要冒泡的轮数</span><br><span class="line">    for ($i = 1; $i &lt; $len; $i++) </span><br><span class="line">    &#123;</span><br><span class="line">        //该层循环用来控制每轮 冒出一个数 需要比较的次数,-$i是次数减少$i</span><br><span class="line">        for ($k = 0; $k &lt; $len - $i; $k++) </span><br><span class="line">        &#123;</span><br><span class="line">            //从小到大排序</span><br><span class="line">            if ($arr[$k] &gt; $arr[$k + 1]) </span><br><span class="line">            &#123;</span><br><span class="line">                $tmp = $arr[$k + 1];</span><br><span class="line">                $arr[$k + 1] = $arr[$k];</span><br><span class="line">                $arr[$k] = $tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用冒泡排序算法，其基本原理如下:  </p><ol><li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置.</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol></blockquote><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下</p><p><img src="/public/static/images/算法/冒泡排序/1.gif" alt=""></p><p>使用冒泡排序为一列数字进行排序的过程如下图所示：</p><p><img src="/public/static/images/算法/冒泡排序/2.gif" alt=""></p><blockquote><p>注意: 尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。  &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="冒泡排序" scheme="http://ioext.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>递推(迭代)算法--递推算法</title>
    <link href="http://ioext.com/2017/12/06/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8(%E8%BF%AD%E4%BB%A3)%E7%AE%97%E6%B3%95--%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://ioext.com/2017/12/06/算法/递推(迭代)算法--递推算法/</id>
    <published>2017-12-06T12:17:48.000Z</published>
    <updated>2018-11-07T03:38:52.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h1><p>要求某个“大”问题，先获得该大问题的同类问题的“最小问题”的结果，然后，如果能够通过最小问题的结果，根据一个“简单算法”而获得比该最小问题“大一级”问题的结果，则就可以根据该规律，一次次持续获得“更大一级”问题的结果，直到“碰到”最大的问题的结果，也就最终的问题结果。  </p><p>举例:<br>1、求5的阶乘:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$qian = 1;                      //1的阶乘,也是&quot;前一个数&quot;的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 2;               //2的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 3;               //3的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘,为什么?</span><br><span class="line">                                //因为,后再往后的代码可能还需要继续使用这个当做前一个数来用</span><br><span class="line"></span><br><span class="line">$hou = $qian * 4;               //4的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 5;               //5的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以上代码的含义,使用循环来完成,就是:</span><br><span class="line">$qian = 1;</span><br><span class="line">for( $i=2; $i&lt;=5; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $hou = $qian * $i;</span><br><span class="line">        $qian = $hou;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;5的阶乘:&quot;.$hou;</span><br></pre></td></tr></table></figure></p><p>在分析一个:求斐波那契数列的第20项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//例子:1,1,2,3,5,8,13,23...</span><br><span class="line">$n1 = 1;        //第一项,也可以认为:第n-2项</span><br><span class="line">$n2 = 1;        //第二项,也可以任务:第n-1项</span><br><span class="line"></span><br><span class="line">for( $i=3; $i&lt;20; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $result = $n1+$n2;</span><br><span class="line">    //即:如果,i=3,此时就得到第3项是:2;</span><br><span class="line">    //也就是现在的数列为:1,1,2</span><br><span class="line">    //在往下思考,如果要求第4项,则怎么办?如下:</span><br><span class="line">    $n = $n2;</span><br><span class="line">    $n2 = $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $result;</span><br></pre></td></tr></table></figure></p><p>再分析一个:<br>数列如:【1】,【2】,3,,6,9,18,27…<br>规律:第n个数是第n-2个数的3倍,已知第一个是1,第二个是2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$n1 = 1;</span><br><span class="line">$n2 = 2;</span><br><span class="line"></span><br><span class="line">for( $i=3; $i &lt;= 20; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $result = $n1*3;//一般规律:当签要求的结果,是第n-2个数的结果乘以3</span><br><span class="line">    $n1 = $n2;      //将一般规律中所需要的&quot;前面数据&quot;预先准备好,以供下一次可能所需</span><br><span class="line">    $n2 = $result;</span><br><span class="line">&#125;</span><br><span class="line">echo $result;</span><br></pre></td></tr></table></figure></p><h3 id="递推算法一般规律"><a href="#递推算法一般规律" class="headerlink" title="递推算法一般规律"></a>递推算法一般规律</h3><p>递推算法通常是用循环来实现，跟函数没有直接关系（虽然也可以写在函数中），其基本模式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$n1 = 某个已知；//并且当做“前一个数据”</span><br><span class="line">for( $i = 第2个；  $i &lt;= 最终n个；  ++$i)</span><br><span class="line">&#123;</span><br><span class="line">    $result  = 对 $n1 进行一个简单计算；</span><br><span class="line">    $n1 = $result;//将已经求得的当前结果值，当做“前一个数据”以供下一次使用！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/public/static/images/算法/递推算法/1.jpg" alt="">  </p><blockquote><p>特别注意:<br> 如果一个问题，既能够用递归算法完成，也能够用递推算法完成，则推荐使用递推算法！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递推算法&quot;&gt;&lt;a href=&quot;#递推算法&quot; class=&quot;headerlink&quot; title=&quot;递推算法&quot;&gt;&lt;/a&gt;递推算法&lt;/h1&gt;&lt;p&gt;要求某个“大”问题，先获得该大问题的同类问题的“最小问题”的结果，然后，如果能够通过最小问题的结果，根据一个“简单算法”而获
      
    
    </summary>
    
    
      <category term="递推算法" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    
      <category term="迭代算法" scheme="http://ioext.com/tags/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://ioext.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="递推" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>递推(迭代)算法--递归算法</title>
    <link href="http://ioext.com/2017/12/06/%E7%AE%97%E6%B3%95/%E9%80%92%E6%8E%A8(%E8%BF%AD%E4%BB%A3)%E7%AE%97%E6%B3%95--%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <id>http://ioext.com/2017/12/06/算法/递推(迭代)算法--递归算法/</id>
    <published>2017-12-06T11:06:13.000Z</published>
    <updated>2018-11-07T03:38:52.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>面对一个大问题（假设为n级问题），如果能够知道ｎ－１级问题的答案，那么就可以轻松求得ｎ级问题的答案，那么此时，我们就可以使用递归算法来解决该问题——按此思路，就可以推论到一个“最小问题”（假设为1级），此时应就是一个已知答案。则该问题就可解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function  digui( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if(  $n == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return  已知答案；</span><br><span class="line">    &#125;</span><br><span class="line">    $result  =  对digui( $n-1 ) 进行简单计算；</span><br><span class="line">    return  $result；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>就是在函数内部，调用自己本身的函数。该函数必须有一种能够“停止调用”的机制。该机制，被称为递归函数的“出口”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1( $n )</span><br><span class="line">&#123;</span><br><span class="line">    echo $n . &quot;&quot;;</span><br><span class="line">    $n++;</span><br><span class="line">    if( $n&lt;10 )</span><br><span class="line">    &#123;</span><br><span class="line">        f1($n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1(5);</span><br></pre></td></tr></table></figure></p><h3 id="递归函数的应用"><a href="#递归函数的应用" class="headerlink" title="递归函数的应用"></a>递归函数的应用</h3><blockquote><p>1、求一个正整数的阶乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1! = 1;                         人为设定                </span><br><span class="line">2! = 1*2;                       = (1!)*2;</span><br><span class="line">3! = 1*2*3;                     = (2!)*3;</span><br><span class="line">4! = 1*2*3*4;                   = (3!)*4;</span><br><span class="line">......</span><br><span class="line">N! = 1*2*3*...*N;               = ((N-1)!)*N;</span><br></pre></td></tr></table></figure></p></blockquote><p>现在我们假设我们做好了”一个函数(jiecheng())”,该函数能计算”N的阶乘”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function jiecheng( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if( $n == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return $n;</span><br><span class="line">    &#125;</span><br><span class="line">    $result = jiecheng( $n-1 )*$n;</span><br><span class="line">    return $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jiecheng(5);</span><br></pre></td></tr></table></figure></p><p>研究该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//传递参数1时的情况:</span><br><span class="line">$t1 = jiecheng(1);//1的阶乘,1</span><br><span class="line"></span><br><span class="line">//传递参数2时的情况:</span><br><span class="line">$t2 = jiecheng(2);//2的阶乘,内部又一次jiecheng(1),将其结果(1)*2,相当于jiecheng(1)*2</span><br><span class="line"></span><br><span class="line">//继续啊:</span><br><span class="line">$t3 = jiecheng(3);//相当于jiecheng(2)*3,即:(jiecheng(1)*2)*3</span><br><span class="line"></span><br><span class="line">$t4 = jiecheng(4);//相当于jiecheng(3)*4,即(((jiecheng(1)*2)*3)*4)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>代码演示<br><img src="/public/static/images/算法/递归算法/1.jpg" alt="">  </p><p>该函数调用过程如下:</p><p><img src="/public/static/images/算法/递归算法/2.jpg" alt="">  </p><h3 id="递归函数总结"><a href="#递归函数总结" class="headerlink" title="递归函数总结"></a>递归函数总结</h3><blockquote><p>1、要求的最终的“大”问题，可以由比其“小一级”的问题的结果经过简单计算得到结论（一般规律）<br>2、则照此规则，可以一次次将“大”问题，化解为“更小一点”的问题。<br>3、在此过程中，会一次次“推论”到“最小一级问题”（特例结果）<br>4、该问题理应知道：要么题目给出，要么是“公理”。<br>5、递归算法，一定是跟“函数”有关的</p></blockquote><h3 id="一个有关阶乘的问题：为什么n-1的时候，没有退出？不是有return-1吗？"><a href="#一个有关阶乘的问题：为什么n-1的时候，没有退出？不是有return-1吗？" class="headerlink" title="一个有关阶乘的问题：为什么n=1的时候，没有退出？不是有return 1吗？"></a>一个有关阶乘的问题：为什么n=1的时候，没有退出？不是有return 1吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function  jiecheng( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if( $n == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return  1;//行3</span><br><span class="line">    &#125;</span><br><span class="line">    $result = jicheng($n - 1 ) * $n;//行5</span><br><span class="line">    return  $result;</span><br><span class="line">&#125;</span><br><span class="line">$v1  = jicheng( 5 );//</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">$s1  = jiecheng(1);//此时，就在行3退出了，直接返回1给了$s1;</span><br><span class="line">$s2  = jiecheng(2);//此时，会在行5执行，但该行先要执行：jiecheng(1); 结果返回1，然后再乘以2，然后在赋值，</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归算法&quot;&gt;&lt;a href=&quot;#递归算法&quot; class=&quot;headerlink&quot; title=&quot;递归算法&quot;&gt;&lt;/a&gt;递归算法&lt;/h1&gt;&lt;p&gt;面对一个大问题（假设为n级问题），如果能够知道ｎ－１级问题的答案，那么就可以轻松求得ｎ级问题的答案，那么此时，我们就可以使用
      
    
    </summary>
    
    
      <category term="递推算法" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    
      <category term="迭代算法" scheme="http://ioext.com/tags/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://ioext.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="递推" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>一家要清退所有低端工程师的创业公司</title>
    <link href="http://ioext.com/2017/11/28/%E6%9D%82%E6%96%87/%E4%B8%80%E5%AE%B6%E8%A6%81%E6%B8%85%E9%80%80%E6%89%80%E6%9C%89%E4%BD%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8/"/>
    <id>http://ioext.com/2017/11/28/杂文/一家要清退所有低端工程师的创业公司/</id>
    <published>2017-11-28T10:15:14.000Z</published>
    <updated>2018-11-07T03:29:57.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/public/static/images/杂文/一家要清退所有低端工程师的创业公司/1.jpg" alt=""></p><ul><li>文/曲凯</li></ul><p>有这么一家创业公司，在发展早期的时候，招了大量的底层员工。  </p><h3 id="别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。"><a href="#别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。" class="headerlink" title="别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。"></a>别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。</h3><p>后来，随着公司发展，这些低端工程师变得可有可无。这些人留下会影响公司的成本结构和报表，何况公司的工位也不够用了。</p><p>于是，管理层就找了个导火索，不顾大家建议，决定在短时间内清退所有低端工程师。</p><p>他们没想到，这些低端工程师里面，也有前端、有后端，他们的突然离开造成了一大波人的恐慌。</p><p>但管理层始终认为，做这件事是为了公司长远的发展，是造福公司中的每个人。</p><h3 id="管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。"><a href="#管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。" class="headerlink" title="管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。"></a>管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。</h3><p>但他们没想到的是，保证公司内部发展的规则和每个员工的权利，从来都不是为了让公司能快速发展，而是为了让公司能避开系统性风险，维持稳定发展。</p><p>一家创业公司早期的指数增长是靠创始人的天赋、能力、远景等等，这个时候如果过于被世俗规则牵绊，反而不是好事。</p><p>但所有公司后期的维系还是要靠规则，这个时候如果还是靠少数人的直觉，就会尾大不掉，遭遇深坑。</p><h3 id="所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。"><a href="#所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。" class="headerlink" title="所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。"></a>所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。</h3><p>而且，其实大多打抱不平的员工，自己也没想明白这件事意味着什么。</p><p>所有留下的非低端工程师，手里都拿着公司的期权和股票，都是和公司绑定在一起的。</p><p>其实在绝大多数人眼里，留下的人都已经是名副其实的既得利益者。</p><p>今天帮低端工程师说话，其实也是站在创业公司的角度，为了让公司更好，也为了让自己更好。</p><p>不然，如果未来哪天低端工程师真的闹起来，觉得所有的底层代码都是自己写的，要把那些所谓的前端和后端工程师都拉出来批一番，要平分他们所获得的功劳，只怕没有一个人会有好日子过。</p><p>关于创业公司和裁员，去年我还写过一篇文章，也是42章经历史上唯一被强制删除的一篇，今天自我阉割后再次发在这里。毕竟过去的一周太过于魔幻现实主义，以此作为纪念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在一年前，当我还是一个投资人的时候，总觉得自己的生活被工作无缝环绕。吃饭、喝咖啡都不用说了，就连偶尔坐个地铁，旁边坐的都是在聊创业和投资的人。</span><br><span class="line"></span><br><span class="line">每次我都很想过去说：</span><br><span class="line"></span><br><span class="line">“孩子，好好上学不好吗？校园代收发快递融不到钱的。”</span><br><span class="line"></span><br><span class="line">“大叔，别做社交软件了好吗？还社群+O2O，真心都死了啊！”</span><br><span class="line"></span><br><span class="line">又过了一段时间，聊创业的人少了，聊资本寒冬的人多了。我觉得这是好事，互联网的天生垄断属性，自然让创业变成一个具有赌博性质的游戏。如果二级市场里的散户是韭菜，那么一级市场里的散户就是炮灰。韭菜割完还能长，炮灰散了就灰飞烟灭了。</span><br><span class="line"></span><br><span class="line">最近，这个趋势又开始向更有意思的方向转变了。我已经很多次在地铁上听到旁边有人在聊：</span><br><span class="line"></span><br><span class="line">“你们公司融到钱了吗？”</span><br><span class="line"></span><br><span class="line">“公司说再待久一点就要发期权，是什么意思？”</span><br><span class="line"></span><br><span class="line">“咱们公司总这么靠投资人养活也不是事啊，什么时候才能赚钱？”</span><br></pre></td></tr></table></figure></p><h3 id="一个很可怕的经济传递就这样在地铁上完成了。"><a href="#一个很可怕的经济传递就这样在地铁上完成了。" class="headerlink" title="一个很可怕的经济传递就这样在地铁上完成了。"></a>一个很可怕的经济传递就这样在地铁上完成了。</h3><p>一大波融到钱的人，招了比他们更多量级的人，然后遇到了资本寒冬，最终焦虑的是投资人和创业者，但真正付出代价的是这些创业公司的从业者们。他们甚至不懂什么是 VC、什么是期权，不懂为什么公司一直在赔钱，还一直有人给钱。但突然有一天，他们觉得自己要开始关心这些问题了，因为他们看到了身边人的窘境，与自己摇摇欲坠的未来。</p><p>可以说，  </p><h3 id="二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。"><a href="#二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。" class="headerlink" title="二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。"></a>二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。</h3><p>所以创业者们真的不要再转发说创业有多难，做 CEO 有多难了。创业者每次看着自己的员工都应该抱有一颗感恩和敬畏的心，最难的永远是这些人。</p><p>我曾经见过凌晨一二点几个外卖员在一起抱团等单子，见过凌晨三四点同城配送的司机为了生计去仓库拉货，见过背着比人还大的包、还要拿着张床坐地铁跑很远去上门按摩的人。他们都是这个世界上最客气的人，他们进门前都要小心翼翼拿出鞋套，走的时候都要鞠个躬想要一个五星好评。</p><p>这些在城市中从早到晚穿行的外卖员、快递员、专车司机和各种互联网工作者，他们的行为和路径像极了我们城市网络中的底层搬运工。这些付出劳动养活自己的人，为什么得不到你们那么巨量的关注？其实，可能只是因为他们离你太近了。</p><p>2015 年的一项政府数据说，全国每天新成立的公司有 12000 家。那么全年就是超过 400 万家公司，假设平均每家公司只有 5 个人，也是影响到 2000 万个人，这还只是 2015 年一年。</p><p>单苏州一个二线城市，政府的目标就已经是要在 2020 年前开 300 个孵化器，对接 30000 家创业公司。而据安永的一份统计说，去年已经有 500 亿美元投进了创投市场。</p><p>你要知道，从专业投资的角度来说，如果一家公司的客户全都是初创企业或小客户，那么这代表着不稳定。政府层面引导的全民创业在短期内创造了就业，但在长期来看，供需关系的失衡几乎是一种必然。</p><p>之前有一篇标题叫《裁员！裁员！裁员！创业者们的寒冬大逃杀》的文章，在朋友圈也是被转了无数次。但大家大都从创业者和投资人的角度感慨，却很少有人问一句，被裁的人去哪了？大逃杀、大逃杀，逃的是资本方、创始人和公司，杀的是谁？</p><p>最后，故事从地铁开始，也从地铁结束好了。</p><p>以前我很讨厌坐地铁抢座的人，觉得那根本就是渺小人格才会做的事情，我才不要同流合污，所以渐渐上了地铁都不坐了，只站着旁观，看到别人抢座我在旁边就会有一种优越感。我觉得这大概和转发并评论的行为差不多，应该叫做“出世”？</p><p>但现在眼前有座的话我就会去坐下，因为这样才能自己掌握资源和主动权，才能保证在老弱妇孺上车的时候可以有人让座给他们。做好自己的事情，尽好自己的责任，为需要的人争取资源，这就应该称为“入世”吧。</p><p>“如果一个人为了钱犯罪，这个人有罪。如果一个人为了面包犯罪，这个社会有罪。”</p><p>我相信这句话本身是对的，但赎罪的方式有很多种，却绝对不仅止于转发。</p><p>最近一周里，有太多的无力感，就是因为我们能做的只有转发。</p><p>希望未来能有越来越多抢到座位的人，把座位让出来。</p><ul><li>本文转载至<a href="https://m.huxiu.com/article/223527.html" target="_blank" rel="noopener">虎嗅网·42章经</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/public/static/images/杂文/一家要清退所有低端工程师的创业公司/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文/曲凯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有这么一家创业公司，在发展早期的时候，招了大量的底层员工。  &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="创业" scheme="http://ioext.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="低端" scheme="http://ioext.com/tags/%E4%BD%8E%E7%AB%AF/"/>
    
      <category term="虎嗅" scheme="http://ioext.com/tags/%E8%99%8E%E5%97%85/"/>
    
      <category term="42章经" scheme="http://ioext.com/tags/42%E7%AB%A0%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则6:开闭原则</title>
    <link href="http://ioext.com/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%996-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/20/设计模式/设计模式六大原则6-开闭原则/</id>
    <published>2017-10-20T15:24:20.000Z</published>
    <updated>2018-11-07T03:38:52.195Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p></li><li><p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p></li><li><p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p></li></ul><p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p><p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p><p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p>说到这里，再回想一下前面说的5项原则， 恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。  </p><p><img src="/public/static/images/设计模式/设计模式六大原则6:开闭原则/1.gif" alt="">  </p><p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。  </p><p><img src="/public/static/images/设计模式/设计模式六大原则6:开闭原则/2.gif" alt="">    </p><p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p><p>到这里，设计模式的六大原则就写完了。主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章，但主要内容主要还是我本人对这六个原则的感悟。写出来的目的一方面是对这六项原则系统地整理一下，一方面也与广大的网友分享，因为设计模式对编程人员来说，的确非常重要。正如有句话叫做一千个读者眼中有一千个哈姆雷特，如果大家对这六项原则的理解跟我有所不同，欢迎留言，大家共同探讨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需
      
    
    </summary>
    
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
      <category term="开闭原则" scheme="http://ioext.com/tags/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则5:迪米特法则</title>
    <link href="http://ioext.com/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%995-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    <id>http://ioext.com/2017/10/20/设计模式/设计模式六大原则5-迪米特法则/</id>
    <published>2017-10-19T17:23:48.000Z</published>
    <updated>2017-10-20T07:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义：一个对象应该对其他对象保持最少的了解。</p></li><li><p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p></li><li><p>解决方案：尽量降低类与类之间的耦合。</p></li></ul><p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p><p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</p><p>迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//总公司员工  </span><br><span class="line">class Employee&#123;  </span><br><span class="line">    private String id;  </span><br><span class="line">    public void setId(String id)&#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getId()&#123;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//分公司员工  </span><br><span class="line">class SubEmployee&#123;  </span><br><span class="line">    private String id;  </span><br><span class="line">    public void setId(String id)&#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getId()&#123;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class SubCompanyManager&#123;  </span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;  </span><br><span class="line">            SubEmployee emp = new SubEmployee();  </span><br><span class="line">            //为分公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class CompanyManager&#123;  </span><br><span class="line">  </span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;30; i++)&#123;  </span><br><span class="line">            Employee emp = new Employee();  </span><br><span class="line">            //为总公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();  </span><br><span class="line">        for(SubEmployee e:list1)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();  </span><br><span class="line">        for(Employee e:list2)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Client&#123;  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        CompanyManager e = new CompanyManager();  </span><br><span class="line">        e.printAllEmployee(new SubCompanyManager());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;  </span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;  </span><br><span class="line">            SubEmployee emp = new SubEmployee();  </span><br><span class="line">            //为分公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void printEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = this.getAllEmployee();  </span><br><span class="line">        for(SubEmployee e:list)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class CompanyManager&#123;  </span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;30; i++)&#123;  </span><br><span class="line">            Employee emp = new Employee();  </span><br><span class="line">            //为总公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;  </span><br><span class="line">        sub.printEmployee();  </span><br><span class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();  </span><br><span class="line">        for(Employee e:list2)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：一个对象应该对其他对象保持最少的了解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决方案：尽量降低类与类之间的耦合。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
      <category term="迪米特法则" scheme="http://ioext.com/tags/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则4:接口隔离原则</title>
    <link href="http://ioext.com/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%994-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/20/设计模式/设计模式六大原则4-接口隔离原则/</id>
    <published>2017-10-19T17:08:33.000Z</published>
    <updated>2018-11-07T03:38:52.209Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p></li><li><p>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p></li><li><p>解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p></li></ul><p>举例来说明接口隔离原则：</p><p><img src="/public/static/images/设计模式/设计模式六大原则4-接口隔离原则/1.jpg" alt="未遵循接口隔离原则的设计">  </p><p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">interface I </span><br><span class="line">&#123;  </span><br><span class="line">    public function method1();  </span><br><span class="line">    public function method2();  </span><br><span class="line">    public function method3();  </span><br><span class="line">    public function method4();  </span><br><span class="line">    public function method5();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class B implements I</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method2() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法2&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method3() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法3&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，  </span><br><span class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">      </span><br><span class="line">    public function method4() &#123;&#125;  </span><br><span class="line">    public function method5() &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class C</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class D implements I</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，  </span><br><span class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。  </span><br><span class="line">    public function method2() &#123;&#125;  </span><br><span class="line">    public function method3() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public function method4() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法4&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method5() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法5&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $a = new A();  </span><br><span class="line">        $a-&gt;depend1(new B());  </span><br><span class="line">        $a-&gt;depend2(new B());  </span><br><span class="line">        $a-&gt;depend3(new B());  </span><br><span class="line">          </span><br><span class="line">        $c = new C();  </span><br><span class="line">        $c-&gt;depend1(new D());  </span><br><span class="line">        $c-&gt;depend2(new D());  </span><br><span class="line">        $c-&gt;depend3(new D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p><p><img src="/public/static/images/设计模式/设计模式六大原则4-接口隔离原则/2.jpg" alt="遵循接口隔离原则的设计">  </p><p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">interface I1 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method1();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface I2 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method2();  </span><br><span class="line">    public function method3();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface I3 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method4();  </span><br><span class="line">    public function method5();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I1 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I2 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I2 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class B implements I1, I2</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I1的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method2() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I2的方法2&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method3() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I2的方法3&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class C</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I1 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125; </span><br><span class="line">    public function depend2(I3 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I3 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class D implements I1, I3</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I1的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method4() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I3的方法4&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method5() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I3的方法5&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。</p><ul><li>其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。</li><li>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li></ul><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li><p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</p></li><li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p></li><li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p></li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方
      
    
    </summary>
    
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
      <category term="接口隔离原则" scheme="http://ioext.com/tags/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则3:依赖倒置原则</title>
    <link href="http://ioext.com/2017/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%993-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/19/设计模式/设计模式六大原则3-依赖倒置原则/</id>
    <published>2017-10-19T12:22:01.000Z</published>
    <updated>2017-11-28T02:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><blockquote><p>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p></blockquote><blockquote><p>解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p></blockquote><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Mother</span><br><span class="line">&#123;  </span><br><span class="line">    public function narrate(Book $book)&#123;  </span><br><span class="line">        echo &quot;妈妈开始讲故事&quot;;  </span><br><span class="line">        echo $book-&gt;getContent(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $mother = new Mother();  </span><br><span class="line">        $mother-&gt;narrate(new Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……</p><p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。<br>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IReader</span><br><span class="line">&#123;</span><br><span class="line">    public function getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader </span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Book implements IReader</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Mother</span><br><span class="line">&#123;  </span><br><span class="line">    public void narrate(IReader $reader)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;妈妈开始讲故事&quot;;  </span><br><span class="line">        echo $reader-&gt;getContent();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $mother = new Mother();  </span><br><span class="line">        $mother-&gt;narrate(new Book());  </span><br><span class="line">        $mother-&gt;narrate(new Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>妈妈开始讲故事<br>林书豪17+9助尼克斯击败老鹰……</p><p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p><p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。<br>在实际编程中，我们一般需要做到如下3点：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有。</li><li>变量的声明类型尽量是抽象类或接口。</li><li><p>使用继承时遵循里氏替换原则。</p><p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="依赖倒置" scheme="http://ioext.com/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/"/>
    
  </entry>
  
</feed>
