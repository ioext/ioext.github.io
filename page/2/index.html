<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="IoexT">
<meta property="og:url" content="http://ioext.com/page/2/index.html">
<meta property="og:site_name" content="IoexT">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IoexT">



  <link rel="alternate" href="/atom.xml" title="IoexT" type="application/atom+xml" />




  <link rel="canonical" href="http://ioext.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IoexT</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IoexT</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">
    <a href="/404.html" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />公益 404</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/12/06/递推(迭代)算法--递推算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/递推(迭代)算法--递推算法/" itemprop="url">
                  递推(迭代)算法--递推算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-06 12:17:48" itemprop="dateCreated datePublished" datetime="2017-12-06T12:17:48Z">2017-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-12-07 06:28:33" itemprop="dateModified" datetime="2017-12-07T06:28:33Z">2017-12-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h1><p>要求某个“大”问题，先获得该大问题的同类问题的“最小问题”的结果，然后，如果能够通过最小问题的结果，根据一个“简单算法”而获得比该最小问题“大一级”问题的结果，则就可以根据该规律，一次次持续获得“更大一级”问题的结果，直到“碰到”最大的问题的结果，也就最终的问题结果。  </p>
<p>举例:<br>1、求5的阶乘:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$qian = 1;                      //1的阶乘,也是&quot;前一个数&quot;的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 2;               //2的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 3;               //3的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘,为什么?</span><br><span class="line">                                //因为,后再往后的代码可能还需要继续使用这个当做前一个数来用</span><br><span class="line"></span><br><span class="line">$hou = $qian * 4;               //4的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 5;               //5的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以上代码的含义,使用循环来完成,就是:</span><br><span class="line">$qian = 1;</span><br><span class="line">for( $i=2; $i&lt;=5; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $hou = $qian * $i;</span><br><span class="line">        $qian = $hou;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;5的阶乘:&quot;.$hou;</span><br></pre></td></tr></table></figure></p>
<p>在分析一个:求斐波那契数列的第20项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//例子:1,1,2,3,5,8,13,23...</span><br><span class="line">$n1 = 1;        //第一项,也可以认为:第n-2项</span><br><span class="line">$n2 = 1;        //第二项,也可以任务:第n-1项</span><br><span class="line"></span><br><span class="line">for( $i=3; $i&lt;20; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $result = $n1+$n2;</span><br><span class="line">    //即:如果,i=3,此时就得到第3项是:2;</span><br><span class="line">    //也就是现在的数列为:1,1,2</span><br><span class="line">    //在往下思考,如果要求第4项,则怎么办?如下:</span><br><span class="line">    $n = $n2;</span><br><span class="line">    $n2 = $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $result;</span><br></pre></td></tr></table></figure></p>
<p>再分析一个:<br>数列如:【1】,【2】,3,,6,9,18,27…<br>规律:第n个数是第n-2个数的3倍,已知第一个是1,第二个是2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$n1 = 1;</span><br><span class="line">$n2 = 2;</span><br><span class="line"></span><br><span class="line">for( $i=3; $i &lt;= 20; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $result = $n1*3;//一般规律:当签要求的结果,是第n-2个数的结果乘以3</span><br><span class="line">    $n1 = $n2;      //将一般规律中所需要的&quot;前面数据&quot;预先准备好,以供下一次可能所需</span><br><span class="line">    $n2 = $result;</span><br><span class="line">&#125;</span><br><span class="line">echo $result;</span><br></pre></td></tr></table></figure></p>
<h3 id="递推算法一般规律"><a href="#递推算法一般规律" class="headerlink" title="递推算法一般规律"></a>递推算法一般规律</h3><p>递推算法通常是用循环来实现，跟函数没有直接关系（虽然也可以写在函数中），其基本模式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$n1 = 某个已知；	//并且当做“前一个数据”</span><br><span class="line">for( $i = 第2个；  $i &lt;= 最终n个；  ++$i)</span><br><span class="line">&#123;</span><br><span class="line">    $result  = 对 $n1 进行一个简单计算；</span><br><span class="line">    $n1 = $result;		//将已经求得的当前结果值，当做“前一个数据”以供下一次使用！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/public/static/images/递推算法/1.jpg" alt="">  </p>
<blockquote>
<p>特别注意:<br> 如果一个问题，既能够用递归算法完成，也能够用递推算法完成，则推荐使用递推算法！！！</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/12/06/递推(迭代)算法--递归算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/递推(迭代)算法--递归算法/" itemprop="url">
                  递推(迭代)算法--递归算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-06 11:06:13" itemprop="dateCreated datePublished" datetime="2017-12-06T11:06:13Z">2017-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-12-07 06:30:03" itemprop="dateModified" datetime="2017-12-07T06:30:03Z">2017-12-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>面对一个大问题（假设为n级问题），如果能够知道ｎ－１级问题的答案，那么就可以轻松求得ｎ级问题的答案，那么此时，我们就可以使用递归算法来解决该问题——按此思路，就可以推论到一个“最小问题”（假设为1级），此时应就是一个已知答案。则该问题就可解了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function  digui( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if(  $n == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return  已知答案；</span><br><span class="line">    &#125;</span><br><span class="line">    $result  =  对digui( $n-1 ) 进行简单计算；</span><br><span class="line">    return  $result；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>就是在函数内部，调用自己本身的函数。该函数必须有一种能够“停止调用”的机制。该机制，被称为递归函数的“出口”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1( $n )</span><br><span class="line">&#123;</span><br><span class="line">    echo $n . &quot;&quot;;</span><br><span class="line">    $n++;</span><br><span class="line">    if( $n&lt;10 )</span><br><span class="line">    &#123;</span><br><span class="line">        f1($n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1(5);</span><br></pre></td></tr></table></figure></p>
<h3 id="递归函数的应用"><a href="#递归函数的应用" class="headerlink" title="递归函数的应用"></a>递归函数的应用</h3><blockquote>
<p>1、求一个正整数的阶乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1! = 1;                         人为设定                </span><br><span class="line">2! = 1*2;                       = (1!)*2;</span><br><span class="line">3! = 1*2*3;                     = (2!)*3;</span><br><span class="line">4! = 1*2*3*4;                   = (3!)*4;</span><br><span class="line">......</span><br><span class="line">N! = 1*2*3*...*N;               = ((N-1)!)*N;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>现在我们假设我们做好了”一个函数(jiecheng())”,该函数能计算”N的阶乘”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function jiecheng( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if( $n == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return $n;</span><br><span class="line">    &#125;</span><br><span class="line">    $result = jiecheng( $n-1 )*$n;</span><br><span class="line">    return $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jiecheng(5);</span><br></pre></td></tr></table></figure></p>
<p>研究该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//传递参数1时的情况:</span><br><span class="line">$t1 = jiecheng(1);//1的阶乘,1</span><br><span class="line"></span><br><span class="line">//传递参数2时的情况:</span><br><span class="line">$t2 = jiecheng(2);//2的阶乘,内部又一次jiecheng(1),将其结果(1)*2,相当于jiecheng(1)*2</span><br><span class="line"></span><br><span class="line">//继续啊:</span><br><span class="line">$t3 = jiecheng(3);//相当于jiecheng(2)*3,即:(jiecheng(1)*2)*3</span><br><span class="line"></span><br><span class="line">$t4 = jiecheng(4);//相当于jiecheng(3)*4,即(((jiecheng(1)*2)*3)*4)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>代码演示<br><img src="/public/static/images/递归算法/1.jpg" alt="">  </p>
<p>该函数调用过程如下:</p>
<p><img src="/public/static/images/递归算法/2.jpg" alt="">  </p>
<h3 id="递归函数总结"><a href="#递归函数总结" class="headerlink" title="递归函数总结"></a>递归函数总结</h3><blockquote>
<p>1、要求的最终的“大”问题，可以由比其“小一级”的问题的结果经过简单计算得到结论（一般规律）<br>2、则照此规则，可以一次次将“大”问题，化解为“更小一点”的问题。<br>3、在此过程中，会一次次“推论”到“最小一级问题”（特例结果）<br>4、该问题理应知道：要么题目给出，要么是“公理”。<br>5、递归算法，一定是跟“函数”有关的</p>
</blockquote>
<h3 id="一个有关阶乘的问题：为什么n-1的时候，没有退出？不是有return-1吗？"><a href="#一个有关阶乘的问题：为什么n-1的时候，没有退出？不是有return-1吗？" class="headerlink" title="一个有关阶乘的问题：为什么n=1的时候，没有退出？不是有return 1吗？"></a>一个有关阶乘的问题：为什么n=1的时候，没有退出？不是有return 1吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function  jiecheng( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if( $n == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return  1;		//行3</span><br><span class="line">    &#125;</span><br><span class="line">    $result = jicheng($n - 1 ) * $n;	//行5</span><br><span class="line">    return  $result;</span><br><span class="line">&#125;</span><br><span class="line">$v1  = jicheng( 5 );	//</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">$s1  = jiecheng(1);	//此时，就在行3退出了，直接返回1给了$s1;</span><br><span class="line">$s2  = jiecheng(2);	//此时，会在行5执行，但该行先要执行：jiecheng(1); 结果返回1，然后再乘以2，然后在赋值，</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/11/28/一家要清退所有低端工程师的创业公司/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/一家要清退所有低端工程师的创业公司/" itemprop="url">
                  一家要清退所有低端工程师的创业公司
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-28 10:15:14 / 修改时间：02:25:22" itemprop="dateCreated datePublished" datetime="2017-11-28T10:15:14Z">2017-11-28</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/public/static/images/一家要清退所有低端工程师的创业公司/1.jpg" alt=""></p>
<ul>
<li>文/曲凯</li>
</ul>
<p>有这么一家创业公司，在发展早期的时候，招了大量的底层员工。  </p>
<h3 id="别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。"><a href="#别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。" class="headerlink" title="别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。"></a>别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。</h3><p>后来，随着公司发展，这些低端工程师变得可有可无。这些人留下会影响公司的成本结构和报表，何况公司的工位也不够用了。</p>
<p>于是，管理层就找了个导火索，不顾大家建议，决定在短时间内清退所有低端工程师。</p>
<p>他们没想到，这些低端工程师里面，也有前端、有后端，他们的突然离开造成了一大波人的恐慌。</p>
<p>但管理层始终认为，做这件事是为了公司长远的发展，是造福公司中的每个人。</p>
<h3 id="管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。"><a href="#管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。" class="headerlink" title="管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。"></a>管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。</h3><p>但他们没想到的是，保证公司内部发展的规则和每个员工的权利，从来都不是为了让公司能快速发展，而是为了让公司能避开系统性风险，维持稳定发展。</p>
<p>一家创业公司早期的指数增长是靠创始人的天赋、能力、远景等等，这个时候如果过于被世俗规则牵绊，反而不是好事。</p>
<p>但所有公司后期的维系还是要靠规则，这个时候如果还是靠少数人的直觉，就会尾大不掉，遭遇深坑。</p>
<h3 id="所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。"><a href="#所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。" class="headerlink" title="所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。"></a>所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。</h3><p>而且，其实大多打抱不平的员工，自己也没想明白这件事意味着什么。</p>
<p>所有留下的非低端工程师，手里都拿着公司的期权和股票，都是和公司绑定在一起的。</p>
<p>其实在绝大多数人眼里，留下的人都已经是名副其实的既得利益者。</p>
<p>今天帮低端工程师说话，其实也是站在创业公司的角度，为了让公司更好，也为了让自己更好。</p>
<p>不然，如果未来哪天低端工程师真的闹起来，觉得所有的底层代码都是自己写的，要把那些所谓的前端和后端工程师都拉出来批一番，要平分他们所获得的功劳，只怕没有一个人会有好日子过。</p>
<p>关于创业公司和裁员，去年我还写过一篇文章，也是42章经历史上唯一被强制删除的一篇，今天自我阉割后再次发在这里。毕竟过去的一周太过于魔幻现实主义，以此作为纪念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在一年前，当我还是一个投资人的时候，总觉得自己的生活被工作无缝环绕。吃饭、喝咖啡都不用说了，就连偶尔坐个地铁，旁边坐的都是在聊创业和投资的人。</span><br><span class="line"></span><br><span class="line">每次我都很想过去说：</span><br><span class="line"></span><br><span class="line">“孩子，好好上学不好吗？校园代收发快递融不到钱的。”</span><br><span class="line"></span><br><span class="line">“大叔，别做社交软件了好吗？还社群+O2O，真心都死了啊！”</span><br><span class="line"></span><br><span class="line">又过了一段时间，聊创业的人少了，聊资本寒冬的人多了。我觉得这是好事，互联网的天生垄断属性，自然让创业变成一个具有赌博性质的游戏。如果二级市场里的散户是韭菜，那么一级市场里的散户就是炮灰。韭菜割完还能长，炮灰散了就灰飞烟灭了。</span><br><span class="line"></span><br><span class="line">最近，这个趋势又开始向更有意思的方向转变了。我已经很多次在地铁上听到旁边有人在聊：</span><br><span class="line"></span><br><span class="line">“你们公司融到钱了吗？”</span><br><span class="line"></span><br><span class="line">“公司说再待久一点就要发期权，是什么意思？”</span><br><span class="line"></span><br><span class="line">“咱们公司总这么靠投资人养活也不是事啊，什么时候才能赚钱？”</span><br></pre></td></tr></table></figure></p>
<h3 id="一个很可怕的经济传递就这样在地铁上完成了。"><a href="#一个很可怕的经济传递就这样在地铁上完成了。" class="headerlink" title="一个很可怕的经济传递就这样在地铁上完成了。"></a>一个很可怕的经济传递就这样在地铁上完成了。</h3><p>一大波融到钱的人，招了比他们更多量级的人，然后遇到了资本寒冬，最终焦虑的是投资人和创业者，但真正付出代价的是这些创业公司的从业者们。他们甚至不懂什么是 VC、什么是期权，不懂为什么公司一直在赔钱，还一直有人给钱。但突然有一天，他们觉得自己要开始关心这些问题了，因为他们看到了身边人的窘境，与自己摇摇欲坠的未来。</p>
<p>可以说，  </p>
<h3 id="二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。"><a href="#二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。" class="headerlink" title="二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。"></a>二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。</h3><p>所以创业者们真的不要再转发说创业有多难，做 CEO 有多难了。创业者每次看着自己的员工都应该抱有一颗感恩和敬畏的心，最难的永远是这些人。</p>
<p>我曾经见过凌晨一二点几个外卖员在一起抱团等单子，见过凌晨三四点同城配送的司机为了生计去仓库拉货，见过背着比人还大的包、还要拿着张床坐地铁跑很远去上门按摩的人。他们都是这个世界上最客气的人，他们进门前都要小心翼翼拿出鞋套，走的时候都要鞠个躬想要一个五星好评。</p>
<p>这些在城市中从早到晚穿行的外卖员、快递员、专车司机和各种互联网工作者，他们的行为和路径像极了我们城市网络中的底层搬运工。这些付出劳动养活自己的人，为什么得不到你们那么巨量的关注？其实，可能只是因为他们离你太近了。</p>
<p>2015 年的一项政府数据说，全国每天新成立的公司有 12000 家。那么全年就是超过 400 万家公司，假设平均每家公司只有 5 个人，也是影响到 2000 万个人，这还只是 2015 年一年。</p>
<p>单苏州一个二线城市，政府的目标就已经是要在 2020 年前开 300 个孵化器，对接 30000 家创业公司。而据安永的一份统计说，去年已经有 500 亿美元投进了创投市场。</p>
<p>你要知道，从专业投资的角度来说，如果一家公司的客户全都是初创企业或小客户，那么这代表着不稳定。政府层面引导的全民创业在短期内创造了就业，但在长期来看，供需关系的失衡几乎是一种必然。</p>
<p>之前有一篇标题叫《裁员！裁员！裁员！创业者们的寒冬大逃杀》的文章，在朋友圈也是被转了无数次。但大家大都从创业者和投资人的角度感慨，却很少有人问一句，被裁的人去哪了？大逃杀、大逃杀，逃的是资本方、创始人和公司，杀的是谁？</p>
<p>最后，故事从地铁开始，也从地铁结束好了。</p>
<p>以前我很讨厌坐地铁抢座的人，觉得那根本就是渺小人格才会做的事情，我才不要同流合污，所以渐渐上了地铁都不坐了，只站着旁观，看到别人抢座我在旁边就会有一种优越感。我觉得这大概和转发并评论的行为差不多，应该叫做“出世”？</p>
<p>但现在眼前有座的话我就会去坐下，因为这样才能自己掌握资源和主动权，才能保证在老弱妇孺上车的时候可以有人让座给他们。做好自己的事情，尽好自己的责任，为需要的人争取资源，这就应该称为“入世”吧。</p>
<p>“如果一个人为了钱犯罪，这个人有罪。如果一个人为了面包犯罪，这个社会有罪。”</p>
<p>我相信这句话本身是对的，但赎罪的方式有很多种，却绝对不仅止于转发。</p>
<p>最近一周里，有太多的无力感，就是因为我们能做的只有转发。</p>
<p>希望未来能有越来越多抢到座位的人，把座位让出来。</p>
<ul>
<li>本文转载至<a href="https://m.huxiu.com/article/223527.html" target="_blank" rel="noopener">虎嗅网·42章经</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/20/设计模式六大原则6-开闭原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/20/设计模式六大原则6-开闭原则/" itemprop="url">
                  设计模式六大原则6:开闭原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-20 15:24:20 / 修改时间：09:22:25" itemprop="dateCreated datePublished" datetime="2017-10-20T15:24:20Z">2017-10-20</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
</li>
<li><p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
</li>
<li><p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
</li>
</ul>
<p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p>
<p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p>
<p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<p>说到这里，再回想一下前面说的5项原则， 恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p>
<p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。  </p>
<p><img src="/public/static/images/设计模式六大原则6:开闭原则/1.gif" alt="">  </p>
<p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。  </p>
<p><img src="/public/static/images/设计模式六大原则6:开闭原则/2.gif" alt="">    </p>
<p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>
<p>到这里，设计模式的六大原则就写完了。主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章，但主要内容主要还是我本人对这六个原则的感悟。写出来的目的一方面是对这六项原则系统地整理一下，一方面也与广大的网友分享，因为设计模式对编程人员来说，的确非常重要。正如有句话叫做一千个读者眼中有一千个哈姆雷特，如果大家对这六项原则的理解跟我有所不同，欢迎留言，大家共同探讨。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/20/设计模式六大原则5-迪米特法则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/20/设计模式六大原则5-迪米特法则/" itemprop="url">
                  设计模式六大原则5:迪米特法则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-19 17:23:48" itemprop="dateCreated datePublished" datetime="2017-10-19T17:23:48Z">2017-10-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-10-20 07:23:47" itemprop="dateModified" datetime="2017-10-20T07:23:47Z">2017-10-20</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>定义：一个对象应该对其他对象保持最少的了解。</p>
</li>
<li><p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
</li>
<li><p>解决方案：尽量降低类与类之间的耦合。</p>
</li>
</ul>
<p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p>
<p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</p>
<p>迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//总公司员工  </span><br><span class="line">class Employee&#123;  </span><br><span class="line">    private String id;  </span><br><span class="line">    public void setId(String id)&#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getId()&#123;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//分公司员工  </span><br><span class="line">class SubEmployee&#123;  </span><br><span class="line">    private String id;  </span><br><span class="line">    public void setId(String id)&#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getId()&#123;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class SubCompanyManager&#123;  </span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;  </span><br><span class="line">            SubEmployee emp = new SubEmployee();  </span><br><span class="line">            //为分公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class CompanyManager&#123;  </span><br><span class="line">  </span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;30; i++)&#123;  </span><br><span class="line">            Employee emp = new Employee();  </span><br><span class="line">            //为总公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();  </span><br><span class="line">        for(SubEmployee e:list1)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();  </span><br><span class="line">        for(Employee e:list2)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Client&#123;  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        CompanyManager e = new CompanyManager();  </span><br><span class="line">        e.printAllEmployee(new SubCompanyManager());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;  </span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;  </span><br><span class="line">            SubEmployee emp = new SubEmployee();  </span><br><span class="line">            //为分公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void printEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = this.getAllEmployee();  </span><br><span class="line">        for(SubEmployee e:list)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class CompanyManager&#123;  </span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;30; i++)&#123;  </span><br><span class="line">            Employee emp = new Employee();  </span><br><span class="line">            //为总公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;  </span><br><span class="line">        sub.printEmployee();  </span><br><span class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();  </span><br><span class="line">        for(Employee e:list2)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p>
<p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/20/设计模式六大原则4-接口隔离原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/20/设计模式六大原则4-接口隔离原则/" itemprop="url">
                  设计模式六大原则4:接口隔离原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-19 17:08:33 / 修改时间：09:22:21" itemprop="dateCreated datePublished" datetime="2017-10-19T17:08:33Z">2017-10-19</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
</li>
<li><p>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>
</li>
<li><p>解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
</li>
</ul>
<p>举例来说明接口隔离原则：</p>
<p><img src="/public/static/images/设计模式六大原则4-接口隔离原则/1.jpg" alt="未遵循接口隔离原则的设计">  </p>
<p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">interface I </span><br><span class="line">&#123;  </span><br><span class="line">    public function method1();  </span><br><span class="line">    public function method2();  </span><br><span class="line">    public function method3();  </span><br><span class="line">    public function method4();  </span><br><span class="line">    public function method5();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class B implements I</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method2() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法2&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method3() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法3&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，  </span><br><span class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">      </span><br><span class="line">    public function method4() &#123;&#125;  </span><br><span class="line">    public function method5() &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class C</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class D implements I</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，  </span><br><span class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。  </span><br><span class="line">    public function method2() &#123;&#125;  </span><br><span class="line">    public function method3() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public function method4() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法4&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method5() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法5&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $a = new A();  </span><br><span class="line">        $a-&gt;depend1(new B());  </span><br><span class="line">        $a-&gt;depend2(new B());  </span><br><span class="line">        $a-&gt;depend3(new B());  </span><br><span class="line">          </span><br><span class="line">        $c = new C();  </span><br><span class="line">        $c-&gt;depend1(new D());  </span><br><span class="line">        $c-&gt;depend2(new D());  </span><br><span class="line">        $c-&gt;depend3(new D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p>
<p><img src="/public/static/images/设计模式六大原则4-接口隔离原则/2.jpg" alt="遵循接口隔离原则的设计">  </p>
<p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">interface I1 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method1();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface I2 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method2();  </span><br><span class="line">    public function method3();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface I3 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method4();  </span><br><span class="line">    public function method5();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I1 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I2 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I2 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class B implements I1, I2</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I1的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method2() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I2的方法2&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method3() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I2的方法3&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class C</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I1 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125; </span><br><span class="line">    public function depend2(I3 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I3 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class D implements I1, I3</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I1的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method4() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I3的方法4&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method5() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I3的方法5&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。</p>
<ul>
<li>其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。</li>
<li>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li>
</ul>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li><p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</p>
</li>
<li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p>
</li>
<li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
</li>
</ul>
<p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/19/设计模式六大原则3-依赖倒置原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/设计模式六大原则3-依赖倒置原则/" itemprop="url">
                  设计模式六大原则3:依赖倒置原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-19 12:22:01" itemprop="dateCreated datePublished" datetime="2017-10-19T12:22:01Z">2017-10-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-28 02:29:43" itemprop="dateModified" datetime="2017-11-28T02:29:43Z">2017-11-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
</blockquote>
<blockquote>
<p>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
</blockquote>
<blockquote>
<p>解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
</blockquote>
<p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Mother</span><br><span class="line">&#123;  </span><br><span class="line">    public function narrate(Book $book)&#123;  </span><br><span class="line">        echo &quot;妈妈开始讲故事&quot;;  </span><br><span class="line">        echo $book-&gt;getContent(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $mother = new Mother();  </span><br><span class="line">        $mother-&gt;narrate(new Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……</p>
<p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。<br>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IReader</span><br><span class="line">&#123;</span><br><span class="line">    public function getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader </span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Book implements IReader</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Mother</span><br><span class="line">&#123;  </span><br><span class="line">    public void narrate(IReader $reader)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;妈妈开始讲故事&quot;;  </span><br><span class="line">        echo $reader-&gt;getContent();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $mother = new Mother();  </span><br><span class="line">        $mother-&gt;narrate(new Book());  </span><br><span class="line">        $mother-&gt;narrate(new Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>妈妈开始讲故事<br>林书豪17+9助尼克斯击败老鹰……</p>
<p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。<br>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li><p>使用继承时遵循里氏替换原则。</p>
<p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/19/设计模式六大原则2-里氏替换原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/设计模式六大原则2-里氏替换原则/" itemprop="url">
                  设计模式六大原则2:里氏替换原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-18 17:08:01" itemprop="dateCreated datePublished" datetime="2017-10-18T17:08:01Z">2017-10-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-10-19 04:01:41" itemprop="dateModified" datetime="2017-10-19T04:01:41Z">2017-10-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p>
<ul>
<li>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</li>
<li>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</li>
<li>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。<br>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。  </li>
</ul>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。  </p>
<p>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">    public function func1( $a, $b )</span><br><span class="line">    &#123;</span><br><span class="line">        return $a-$b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public function main()</span><br><span class="line">    &#123;</span><br><span class="line">        $oModel = new A();</span><br><span class="line">        $oModel-&gt;func1(100,50);</span><br><span class="line">        $oModel-&gt;func1(100,80);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果:<br>100-50=50<br>100-80=20     </p>
<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p>
<ul>
<li>两数相减。</li>
<li>两数相加，然后再加100。<br>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">    public function func1( $a, $b )</span><br><span class="line">    &#123;</span><br><span class="line">        return $a+$b;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public function func1( $a, $b )</span><br><span class="line">    &#123;</span><br><span class="line">        return func1($a,$b)+100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public function main()</span><br><span class="line">    &#123;</span><br><span class="line">        $oModel = new B();</span><br><span class="line">        $oModel-&gt;func1(100,50);</span><br><span class="line">        $oModel-&gt;func1(100,80);</span><br><span class="line">        $oModel-&gt;func2(100,20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>类B完成后，运行结果：<br>100-50=150<br>100-80=180<br>100+20+100=220  </p>
<p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<blockquote>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。  </li>
</ul>
</blockquote>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？  </p>
<p>后果就是：你写的代码出问题的几率将会大大增加。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/18/设计模式六大原则1-单一职责原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/设计模式六大原则1-单一职责原则/" itemprop="url">
                  设计模式六大原则1:单一职责原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-17 18:18:05" itemprop="dateCreated datePublished" datetime="2017-10-17T18:18:05Z">2017-10-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-10-19 03:29:02" itemprop="dateModified" datetime="2017-10-19T03:29:02Z">2017-10-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>定义:不要存在多于一个导致类变更的原因。通俗的说,即一个类只负责一项职责。</li>
<li>问题由来:类T负责两个不同的职责:职责P1,职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</li>
<li>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。  </li>
</ul>
<p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</p>
<p>比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）<br> 举例说明，用一个类描述动物呼吸这个场景：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">    public function breathe( $animal )&#123;  </span><br><span class="line">        echo $animal.&quot;呼吸空气&quot;;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main( $arg )&#123;  </span><br><span class="line">        $animal = new Animal();  </span><br><span class="line">        $animal-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $animal-&gt;reathe(&quot;羊&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>牛呼吸空气<br>羊呼吸空气<br>猪呼吸空气</p>
<p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Terrestrial&#123;  </span><br><span class="line">    public function breathe( $animal )&#123;  </span><br><span class="line">        echo $animal.&quot;呼吸空气&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Aquatic&#123;  </span><br><span class="line">    public function breathe( $animal)&#123;  </span><br><span class="line">        echo $animal.&quot;呼吸水&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main( $args )&#123;  </span><br><span class="line">        $terrestrial = new Terrestrial();  </span><br><span class="line">        $terrestrial-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $terrestrial-&gt;breathe(&quot;羊&quot;);  </span><br><span class="line">        $terrestrial-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">          </span><br><span class="line">        $aquatic = new Aquatic();  </span><br><span class="line">        $aquatic-&gt;breathe(&quot;鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;     </span><br><span class="line">    public function breathe($animal)</span><br><span class="line">    &#123;  </span><br><span class="line">        if(&quot;鱼&quot; == $animal))</span><br><span class="line">        &#123;  </span><br><span class="line">            echo $animal.&quot;呼吸水&quot;);  </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;  </span><br><span class="line">           echo $animal.&quot;呼吸空气&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $animal = new Animal();  </span><br><span class="line">        $animal-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;羊&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">    public function breathe($animal)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo $animal.&quot;呼吸空气&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public function breathe2($animal)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo $animal.&quot;呼吸水&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main($args)&#123;  </span><br><span class="line">        $animal = new Animal();  </span><br><span class="line">        $animal-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;羊&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">        $animal-&gt;breathe2(&quot;鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；<br>        例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。<br>遵循单一职责原的优点有：</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。<br>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ioext.com/2017/10/17/Laravel生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ioext">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IoexT">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/Laravel生命周期/" itemprop="url">
                  Laravel生命周期的核心概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-16 18:04:26" itemprop="dateCreated datePublished" datetime="2017-10-16T18:04:26Z">2017-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-10-18 06:45:58" itemprop="dateModified" datetime="2017-10-18T06:45:58Z">2017-10-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>工欲善其事，必先利其器。在开发Xblog的过程中，稍微领悟了一点Laravel的思想。确实如此，这篇文章读完你可能并不能从无到有写出一个博客，但知道Laravel的核心概念之后，当你再次写起Laravel时，会变得一目了然胸有成竹.  </p>
<h2 id="PHP的生命周期"><a href="#PHP的生命周期" class="headerlink" title="PHP的生命周期"></a>PHP的生命周期</h2><p>万物皆有他的生命周期。熟悉Android的同学一定熟悉Android最经典的Activity的生命周期，Laravel 也不例外，Laravel应用程序也有自己的生命周期。Laravel是什么？一个PHP框架。所以要想真正说清Laravel的生命周期，必须说清PHP的生命周期。原文参考这里，这里做个总结。  </p>
<p>PHP有两种运行模式，WEB模式和CLI（命令行）模式。当我们在终端敲入php这个命令的时候，使用的是CLI模式；当使用Nginx或者别web服务器作为宿主处理一个到来的请求时，会调用PHP运行，此时使用的是WEB模式。当我们请求一个PHP文件时，比如Laravel 的public\index.php文件时，PHP为了完成这次请求，会发生5个阶段的生命周期切换：</p>
<p>1、模块初始化（MINIT），即调用php.ini中指明的扩展的初始化函数进行初始化工作，如mysql扩展。</p>
<p>2、请求初始化（RINIT），即初始化为执行本次脚本所需要的变量名称和变量值内容的符号表，如$_SESSION变量。</p>
<p>3、执行该PHP脚本。</p>
<p>4、请求处理完成(Request Shutdown)，按顺序调用各个模块的RSHUTDOWN方法，对每个变量调用unset函数，如unset $_SESSION变量。</p>
<p>5、关闭模块(Module Shutdown) ， PHP调用每个扩展的MSHUTDOWN方法，这是各个模块最后一次释放内存的机会。这意味着没有下一个请求了。  </p>
<p>WEB模式和CLI（命令行）模式很相似，区别是：CLI 模式会在每次脚本执行经历完整的5个周期，因为你脚本执行完不会有下一个请求；而WEB模式为了应对并发，可能采用多线程，因此生命周期1和5有可能只执行一次，下次请求到来时重复2-4的生命周期，这样就节省了系统模块初始化所带来的开销。  </p>
<p>可以看到，PHP生命周期是很对称的。说了这么多，就是为了定位Laravel运行在哪里，没错，Laravel仅仅运行再第三个阶段：  </p>
<p><img src="/public/static/images/laravel生命周期/1.png" alt="Image text">  </p>
<p>知道这些有什么用？你可以优化你的Laravel代码，可以更加深入的了解Larave的singleton（单例）。至少你知道了，每一次请求结束，Php的变量都会unset，Laravel的singleton只是在某一次请求过程中的singleton；你在Laravel 中的静态变量也不能在多个请求之间共享，因为每一次请求结束都会unset。理解这些概念，是写高质量代码的第一步，也是最关键的一步。因此记住，PHP是一种脚本语言，所有的变量只会在这一次请求中生效，下次请求之时已被重置，而不像Java静态变量拥有全局作用</p>
<p>好了，开始Laravel的生命周期。  </p>
<h2 id="Laravel的生命周期"><a href="#Laravel的生命周期" class="headerlink" title="Laravel的生命周期"></a>Laravel的生命周期</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Laravel 的生命周期从public\index.php开始，从public\index.php结束</p>
<p><img src="/public/static/images/laravel生命周期/2.png" alt="Image text">  </p>
<p>注意：以下几图箭头均代表Request流向  </p>
<p>这么说有点草率，但事实确实如此。下面是public\index.php的全部源码（Laravel源码的注释是最好的Laravel文档），更具体来说可以分为四步：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. require __DIR__.&apos;/../bootstrap/autoload.php&apos;;</span><br><span class="line"></span><br><span class="line">2. $app = require_once __DIR__.&apos;/../bootstrap/app.php&apos;;</span><br><span class="line">   $kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br><span class="line"></span><br><span class="line">3. $response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">   );</span><br><span class="line">   $response-&gt;send();</span><br><span class="line"></span><br><span class="line">4. $kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure>
<p>这四步详细的解释是：</p>
<p>1.注册加载composer自动生成的class loader，包括所有你composer require的依赖（对应代码1）.</p>
<p>2.生成容器Container，Application实例，并向容器注册核心组件（HttpKernel，ConsoleKernel，ExceptionHandler）（对应代码2，容器很重要，后面详细讲解）。 </p>
<p>3.处理请求，生成并发送响应（对应代码3，毫不夸张的说，你99%的代码都运行在这个小小的handle方法里面）。 </p>
<p>4.请求结束，进行回调（对应代码4，还记得可终止中间件吗？没错，就是在这里回调的）。  </p>
<p><img src="/public/static/images/laravel生命周期/3.png" alt="Image text"> </p>
<h3 id="启动Laravel基础服务"><a href="#启动Laravel基础服务" class="headerlink" title="启动Laravel基础服务"></a>启动Laravel基础服务</h3><p>第一步注册加载composer自动生成的class loader就是加载初始化第三方依赖，不属于Laravel核心，到此为止。<br>第二步生成容器Container，并向容器注册核心组件，这里牵涉到了容器Container和合同Contracts，这是Laravel的重点，下面将详细讲解。<br>重点是第三步处理请求，生成并发送响应。<br>首先Laravel框架捕获到用户发到public\index.php的请求，生成Illuminate\Http\Request实例，传递给这个小小的handle方法。在方法内部，将该$request实例绑定到第二步生成的$app容器上。让后在该请求真正处理之前，调用bootstrap方法，进行必要的加载和注册，如检测环境，加载配置，注册Facades（假象），注册服务提供者，启动服务提供者等等。这是一个启动数组，具体在Illuminate\Foundation\Http\Kernel中，包括：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected $bootstrappers = [</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\DetectEnvironment&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\LoadConfiguration&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\ConfigureLogging&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\HandleExceptions&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\RegisterFacades&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\RegisterProviders&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\BootProviders&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>看类名知意，Laravel是按顺序遍历执行注册这些基础服务的，注意顺序：Facades先于ServiceProviders，Facades也是重点，后面说，这里简单提一下，注册Facades就是注册config\app.php中的aliases 数组，你使用的很多类，如Auth，Cache,DB等等都是Facades；而ServiceProviders的register方法永远先于boot方法执行，以免产生boot方法依赖某个实例而该实例还未注册的现象。</p>
<p>所以，你可以在ServiceProviders的register方法中使用任何Facades，在ServiceProviders的boot方法中使用任何register方法中注册的实例或者Facades，这样绝不会产生依赖某个类而未注册的现象。</p>
<h3 id="将请求传递给路由"><a href="#将请求传递给路由" class="headerlink" title="将请求传递给路由"></a>将请求传递给路由</h3><p>注意到目前为止，Laravel 还没有执行到你所写的主要代码（ServiceProviders中的除外），因为还没有将请求传递给路由。</p>
<p>在Laravel基础的服务启动之后，就要把请求传递给路由了。传递给路由是通过Pipeline（另开篇章讲解）来传递的，但是Pipeline有一堵墙，在传递给路由之前所有请求都要经过，这堵墙定义在app\Http\Kernel.php中的$middleware数组中，没错就是中间件，默认只有一个CheckForMaintenanceMode中间件，用来检测你的网站是否暂时关闭。这是一个全局中间件，所有请求都要经过，你也可以添加自己的全局中间件。</p>
<p>然后遍历所有注册的路由，找到最先符合的第一个路由，经过它的路由中间件，进入到控制器或者闭包函数，执行你的具体逻辑代码。</p>
<p>所以，在请求到达你写的代码之前，Laravel已经做了大量工作，请求也经过了千难万险，那些不符合或者恶意的的请求已被Laravel隔离在外。   </p>
<p><img src="/public/static/images/laravel生命周期/4.png" alt="Image text"> </p>
<h3 id="服务容器"><a href="#服务容器" class="headerlink" title="服务容器"></a>服务容器</h3><p>服务容器就是一个普通的容器，用来装类的实例，然后在需要的时候再取出来。用更专业的术语来说是服务容器实现了控制反转（Inversion of Control，缩写为IoC），意思是正常情况下类A需要一个类B的时候，我们需要自己去new类B，意味着我们必须知道类B的更多细节，比如构造函数，随着项目的复杂性增大，这种依赖是毁灭性的。控制反转的意思就是，将类A主动获取类B的过程颠倒过来变成被动，类A只需要声明它需要什么，然后由容器提供。</p>
<p><img src="/public/static/images/laravel生命周期/5.png" alt="Image text">  </p>
<p>这样做的好处是，类A不依赖于类B的实现，这样在一定程度上解决了耦合问题。</p>
<p>在Laravel的服务容器中，为了实现控制反转，可以有以下两种：</p>
<p>依赖注入（Dependency Injection）。<br>绑定。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入是一种类型提示，举官网的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * The user repository implementation.</span><br><span class="line">     *</span><br><span class="line">     * @var UserRepository</span><br><span class="line">     */</span><br><span class="line">    protected $users;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new controller instance.</span><br><span class="line">     *</span><br><span class="line">     * @param  UserRepository  $users</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function __construct(UserRepository $users)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;users = $users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Show the profile for the given user.</span><br><span class="line">     *</span><br><span class="line">     * @param  int  $id</span><br><span class="line">     * @return Response</span><br><span class="line">     */</span><br><span class="line">    public function show($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $user = $this-&gt;users-&gt;find($id);</span><br><span class="line"></span><br><span class="line">        return view(&apos;user.profile&apos;, [&apos;user&apos; =&gt; $user]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里UserController需要一个UserRepository实例，我们只需在构造方法中声明我们需要的类型，容器在实例化UserController时会自动生成UserRepository的实例（或者实现类，因为UserRepository可以为接口），而不用主动去获取UserRepository的实例，这样也就避免了了解UserRepository的更多细节，也不用解决UserRepository所产生的依赖，我们所做的仅仅是声明我们所需要的类型，所有的依赖问题都交给容器去解决。（Xblog使用了Repository的是设计模式，大家可以参考）</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>绑定操作一般在ServiceProviders中的register方法中，最基本的绑定是容器的bind方法，它接受一个类的别名或者全名和一个闭包来获取实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;app-&gt;bind(&apos;XblogConfig&apos;, function ($app) &#123;</span><br><span class="line">    return new MapRepository();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>还有一个singleton方法，和bind写法没什么区别。你也可以绑定一个已经存在的对象到容器中，上文中提到的request实例就是通过这种方法绑定到容器的：$this-&gt;app-&gt;instance(‘request’, $request);。绑定之后，我们可以通过一下几种方式来获取绑定实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  app(&apos;XblogConfig&apos;);</span><br><span class="line"></span><br><span class="line">2.  app()-&gt;make(&apos;XblogConfig&apos;);</span><br><span class="line"></span><br><span class="line">3.  app()[&apos;XblogConfig&apos;];</span><br><span class="line"></span><br><span class="line">4.  resolve(&apos;XblogConfig&apos;);</span><br></pre></td></tr></table></figure>
<p>以上四种方法均会返回获得MapRepository的实例，唯一的区别是，在一次请求的生命周期中，bind方法的闭包会在每一次调用以上四种方法时执行，singleton方法的闭包只会执行一次。在使用中，如果每一个类要获的不同的实例，或者需要“个性化”的实例时，这时我们需要用bind方法以免这次的使用对下次的使用造成影响；如果实例化一个类比较耗时或者类的方法不依赖该生成的上下文，那么我们可以使用singleton方法绑定。singleton方法绑定的好处就是，如果在一次请求中我们多次使用某个类，那么只生成该类的一个实例将节省时间和空间。</p>
<p>你也可以绑定接口与实现，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Http\Kernel::class,</span><br><span class="line">    App\Http\Kernel::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上文讲述的Laravel的生命周期的第二步，Laravel默认（在bootstrap\app.php文件中）绑定了Illuminate\Contracts\Http\Kernel，Illuminate\Contracts\Console\Kernel，Illuminate\Contracts\Debug\ExceptionHandler接口的实现类，这些是实现类框架的默认自带的。但是你仍然可以自己去实现。</p>
<p>还有一种上下文绑定，就是相同的接口，在不同的类中可以自动获取不同的实现，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;app-&gt;when(PhotoController::class)</span><br><span class="line">          -&gt;needs(Filesystem::class)</span><br><span class="line">          -&gt;give(function () &#123;</span><br><span class="line">              return Storage::disk(&apos;local&apos;);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">$this-&gt;app-&gt;when(VideoController::class)</span><br><span class="line">          -&gt;needs(Filesystem::class)</span><br><span class="line">          -&gt;give(function () &#123;</span><br><span class="line">              return Storage::disk(&apos;s3&apos;);</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>
<p>上述表明，同样的接口Filesystem，使用依赖注入时，在PhotoController中获取的是local存储而在VideoController中获取的是s3存储。</p>
<h3 id="Contracts-amp-Facades（契约-amp-门面）"><a href="#Contracts-amp-Facades（契约-amp-门面）" class="headerlink" title="Contracts &amp; Facades（契约&amp;门面）"></a>Contracts &amp; Facades（契约&amp;门面）</h3><p>Laravel 还有一个强大之处是，比如你只需在配置文件中指明你需要的缓存驱动（redis，memcached，file……），Laravel 就自动办你切换到这种驱动，而不需要你针对某种驱动更改逻辑和代码。Why? 很简单，Laravel定义了一系列Contracts（翻译：契约），本质上是一系列PHP接口，一系列的标准，用来解耦具体需求对实现的依赖关系。其实真正强大的公司是制定标准的公司，程序也是如此，好的标准（接口）尤为重要。当程序变得越来大，这种通过合同或者接口来解耦所带来的可扩展性和可维护性是无可比拟的。</p>
<p><img src="/public/static/images/laravel生命周期/6.png" alt="Image text">  </p>
<p>上图不使用Contracts的情况下，对于一种逻辑，我们只能得到一种结果（方块），如果变更需求，意味着我们必须重构代码和逻辑。但是在使用Contracts的情况下，我们只需要按照接口写好逻辑，然后提供不同的实现，就可以在不改动代码逻辑的情况下获得更加多态的结果。</p>
<p>这么说有点抽象，举一个真实的例子。在完成Xblog的初期，我使用了缓存，所以导致Repository中充满了和cache相关的方法：remember，flush，forget等等。后来国外网友反映，简单的博客并不一定需要缓存。所以我决定把它变成可选，但因为代码中充满和cache相关的方法，实现起来并不是很容易。于是想起Laravel的重要概念Contracts。于是，我把与缓存有关的方法抽象出来形成一个Contracts:XblogCache，实际操作只与Contracts有关，这样问题就得到了解决，而几乎没有改变原有的逻辑。XblogCache的代码如下<a href="https://github.com/lufficc/Xblog/blob/master/app/Contracts/XblogCache.php" target="_blank" rel="noopener">源码点击这里</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace App\Contracts;</span><br><span class="line">use Closure;</span><br><span class="line">interface XblogCache</span><br><span class="line">&#123;</span><br><span class="line">    public function setTag($tag);</span><br><span class="line">    public function setTime($time_in_minute);</span><br><span class="line">    public function remember($key, Closure $entity, $tag = null);</span><br><span class="line">    public function forget($key, $tag = null);</span><br><span class="line">    public function clearCache($tag = null);</span><br><span class="line">    public function clearAllCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我又完成了两个实现类：Cacheable和NoCache：</p>
<p>1、实现具体缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Cacheable implements XblogCache</span><br><span class="line">&#123;</span><br><span class="line">    public $tag;</span><br><span class="line">    public $cacheTime;</span><br><span class="line">    public function setTag($tag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;tag = $tag;</span><br><span class="line">    &#125;</span><br><span class="line">    public function remember($key, Closure $entity, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        return cache()-&gt;tags($tag == null ? $this-&gt;tag : $tag)-&gt;remember($key, $this-&gt;cacheTime, $entity);</span><br><span class="line">    &#125;</span><br><span class="line">    public function forget($key, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        cache()-&gt;tags($tag == null ? $this-&gt;tag : $tag)-&gt;forget($key);</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearCache($tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        cache()-&gt;tags($tag == null ? $this-&gt;tag : $tag)-&gt;flush();</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearAllCache()</span><br><span class="line">    &#123;</span><br><span class="line">        cache()-&gt;flush();</span><br><span class="line">    &#125;</span><br><span class="line">    public function setTime($time_in_minute)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;cacheTime = $time_in_minute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1、不缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class NoCache implements XblogCache</span><br><span class="line">&#123;</span><br><span class="line">    public function setTag($tag)</span><br><span class="line">    &#123;</span><br><span class="line">    // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function setTime($time_in_minute)</span><br><span class="line">    &#123;</span><br><span class="line">    // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function remember($key, Closure $entity, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        /**</span><br><span class="line">         * directly return</span><br><span class="line">         */</span><br><span class="line">        return $entity();</span><br><span class="line">    &#125;</span><br><span class="line">    public function forget($key, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearCache($tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearAllCache()</span><br><span class="line">    &#123;</span><br><span class="line">        // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再利用容器的绑定，根据不同的配置，返回不同的实现<a href="https://github.com/lufficc/Xblog/blob/master/app/Providers/CacheServiceProvider.php#L28-L34" target="_blank" rel="noopener">源码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public function register()</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;app-&gt;bind(&apos;XblogCache&apos;, function ($app) &#123;</span><br><span class="line">        if (config(&apos;cache.enable&apos;) == &apos;true&apos;) &#123;</span><br><span class="line">            return new Cacheable();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new NoCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，就实现了缓存的切换而不需要更改你的具体逻辑代码。当然依靠接口而不依靠具体实现的好处不仅仅这些。实际上，Laravel所有的核心服务都是实现了某个Contracts接口（都在Illuminate\Contracts\文件夹下面），而不是依赖具体的实现，所以完全可以在不改动框架的前提下，使用自己的代码改变Laravel框架核心服务的实现方式。</p>
<p>说一说Facades。在我们学习了容器的概念后，Facades就变得十分简单了。在我们把类的实例绑定到容器的时候相当于给类起了个别名，然后覆盖Facade的静态方法getFacadeAccessor并返回你的别名，然后你就可以使用你自己的Facade的静态方法来调用你绑定类的动态方法了。其实Facade类利用了__callStatic() 这个魔术方法来延迟调用容器中的对象的方法，这里不过多讲解，你只需要知道Facade实现了将对它调用的静态方法映射到绑定类的动态方法上，这样你就可以使用简单类名调用而不需要记住长长的类名。这也是Facades的中文翻译为假象的原因</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Laravel强大之处不仅仅在于它给你提供了一系列脚手架，比如超级好用的ORM，基于Carbon的时间处理，以及文件存储等等功能。但是Laravel的核心非常非常简单：利用容器和抽象解耦，实现高扩展性。容器和抽象是所有大型框架必须解决的问题，像Java的Spring，Android的Dagger2等等都是围绕这几个问题的。所以本质上讲，Laravel之所以强大出名，是因为它的设计，思想，可扩展性。而Laravel的好用功能只是官方基于这些核心提供的脚手架，你同样也可以很轻松的添加自己的脚手架。</p>
<p>所以不要觉得Laravel强大是因为他提供的很多功能，而是它的设计模式和思想。</p>
<p>理解Laravel生命周期和请求的生命周期概念。<br>所有的静态变量和单例，在下一个请求到来时都会重新初始化。<br>将耗时的类或者频繁使用的类用singleton绑定。<br>将变化选项的抽象为Contracts，依赖接口不依赖具体实现。</p>
<p>本文转载至<a href="https://lufficc.com/blog/the-core-conception-of-laravel" target="_blank" rel="noopener">lufficc的网站</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ioext</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ioext" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:ioext@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ioext</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
