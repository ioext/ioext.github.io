<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ioext</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ioext.com/"/>
  <updated>2018-10-12T09:03:54.729Z</updated>
  <id>http://ioext.com/</id>
  
  <author>
    <name>ioext</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>崔永元：别再让孩子聪明伶俐地进去呆若木鸡地出来</title>
    <link href="http://ioext.com/2018/10/12/%E5%B4%94%E6%B0%B8%E5%85%83%EF%BC%9A%E5%88%AB%E5%86%8D%E8%AE%A9%E5%AD%A9%E5%AD%90%E8%81%AA%E6%98%8E%E4%BC%B6%E4%BF%90%E5%9C%B0%E8%BF%9B%E5%8E%BB%E5%91%86%E8%8B%A5%E6%9C%A8%E9%B8%A1%E5%9C%B0%E5%87%BA%E6%9D%A5/"/>
    <id>http://ioext.com/2018/10/12/崔永元：别再让孩子聪明伶俐地进去呆若木鸡地出来/</id>
    <published>2018-10-12T14:14:58.000Z</published>
    <updated>2018-10-12T09:03:54.729Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/public/static/images/崔永元/别再让孩子聪明伶俐地进去呆若木鸡地出来/1.jpg" alt="Image text"><br>作者：崔 永 元</p><p>侄子在读高二，考了一道历史题：成吉思汗的继承人窝阔台，公元哪一年死？最远打到哪里？答不出来，我帮他查找资料，所以到现在我都记得，是打到现在的匈牙利附近？</p><p>在一次偶然的机会，我发现美国世界史这道题目不是这样考的？它的题目是这样的：成吉思汗的继承人窝阔台，当初如果没有死，欧洲会发生什么变化？试从经济、政治、社会三方面分析？</p><p>有个学生是这样回答的：这位蒙古领导人如果当初没有死，那么可怕的黑死病，就不会被带到欧洲去，后来才知道那个东西是老鼠身上的跳蚤引起的鼠疫。但是六百多年前，黑死病在欧洲猖獗的时候，谁晓得这个叫做鼠疫？如果没有黑死病，神父跟修女就不会死亡。神父跟修女如果没有死亡，就不会怀疑上帝的存在。如果没有怀疑上帝的存在，就不会有意大利弗罗伦斯的文艺复兴？</p><p>如果没有文艺复兴，西班牙、南欧就不会强大，西班牙无敌舰队就不可能建立。如果西班牙、意大利不够强大，盎格鲁—撒克逊会提早200年强大，日耳曼会控制中欧，奥匈帝国就不可能存在？</p><p>教师一看“棒，分析得好。”但他们没有分数，只有等级A。其实这种题目老师是没有标准答案的，可是大家都要思考。</p><p>不久前，我去了趟日本，日本总是和我们在历史问题上产生纠葛，所以我在日本很注意高中生的教科书？<br>他们的教师给高中生布置了这样一道题：日本跟中国100年打一次仗，19世纪打了日清战争（即甲午战争），20世纪打了一场日中战争（即抗日战争），21世纪如果日本跟中国开火，你认为大概是什么时候？可能的远因和近因在哪里？如果日本赢了，是赢在什么地方？输了是输在什么条件上？分析之？</p><p>其中有个高中生是这样分析的：我们跟中国很可能在台湾回到中国以后，有一场激战。台湾如果回到中国，中国会把基隆与高雄封锁，台湾海峡就会变成中国的内海，我们的油轮就统统走右边，走基隆和高雄的右边。这样，会增加日本的运油成本。我们的石油从波斯湾出来跨过印度洋，穿过马六甲海峡，上中国南海，跨台湾海峡进东海到日本海，这是石油生命线，中国政府如果把台湾海峡封锁起来，我们的货轮一定要从那里经过，我们的主力舰和驱逐舰就会出动，中国海军一看到日本出兵，马上就会上场，就开打！</p><p>按照判断，公元2015年至2020年之间，这场战争可能爆发。所以，我们现在就要做对华抗战的准备？</p><p>我看其他学生的判断，也都是中国跟日本的磨擦会从东海从台湾海峡开始，时间判断是 2015年至2020年之间？</p><p>这种题目和答案都太可怕了。</p><p>撇开政治因素来看这道题，我们的历史教育就很有问题。翻开我们的教科书，题目是这样出的：甲午战争是哪一年爆发的？签订的叫什么条约？割让多少土地？赔偿多少银两？？每个学生都努力做答案。结果我们一天到晚研究什么时候割让辽东半岛，什么时候丢了台湾、澎湖、赔偿二万银两，1894年爆发甲午战争、1895 年签订马关条约，背得滚瓜烂熟，都是一大堆枯燥无味的数字。</p><p>那又怎么样，反正都赔了嘛！银两都给了嘛！最主要的是将来可能会怎样！</p><p>人家是在培养能力，而我们是在灌输知识，这是值得深思的部份！</p><p>看外面的教育，再看我们的教育？</p><p>老妈去参加我侄子的家长会，带回了两套侄子的考试试卷，我很好奇，拿过来看了现在小学生的试卷后，我震惊了！这是什么狗屁教育？这样的教育有希望吗？？下面给大家详细说说我看到了什么？</p><p>侄子在本市某著名小学读书，有这么几道题。</p><p>一个春天的夜晚，一个久别家乡的人，望着皎洁的月光不禁思念起了故乡，于是吟起了一首诗：（），（）？</p><p>我看到侄子答的是：举头望明月，低头思故乡。但后面是一把大大的X，我就奇怪了，我也是想到的这2句。好奇的问侄子，这个不对？？那答案是什么？侄子说标准答案是：春风又绿江南岸，明月何时照我还？哎，这就奇怪了，因为是个春天的夜晚，就要是这句有春风的？？？要这个思念故乡的人不是江南的，是不可能说出春风又绿江南岸这句话的！！！举头望明月，低头思故乡应该更准确。再扯远点，思念故乡，一千个人可以吟一千句不一样的诗，这个也可以有标准答案的么？</p><p>接下来是默写，题目是：我们学过《桂林山水》一文，请将下面句子默写下来，然后就是整段的要默写，这有什么用？死记硬背别人的文字有什么用？</p><p>还有个题目，《匆匆》这篇课文，是现代著名作家朱自清先生写的，同学们都很喜欢这篇散文，你能把自己最喜欢，印象最深刻的一句写下来吗？我侄子写的是：我的日子滴在时间的流里，没有声音，也没有影子。后面一把好大的X。标准答案竟然是：但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？这就更奇怪了，一篇文章，你可以喜欢这句，我可以喜欢那句，难道最喜欢的一句话也要统一么？为什么“我的日子滴在时间的流里，没有声音，也没有影子。”这句不能喜欢？就一定要喜欢“但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？”这句？？？我觉得这个题目应该是“你能把老师最喜欢，印象最深刻的一句写下来吗？”才对！？</p><p>再看别的试卷，更莫名其妙了，比如请说出阿拉伯数字的来历，是哪个国家创造的？侄子不知道，问我，我也不知道。我只好去搜一下，才知道是古印度人发明的。莫非我吃块猪肉，还一定得知道它是哪个养猪场养出来的？</p><p>最后有个题目让我彻底崩溃了：请用一句话说明π的含义。侄子回答π的含义是圆周率。竟然打的是X，这就奇怪了，正好我老婆大学说读的是理科，我马上问她，π是什么意思，她说圆周率啊。两个人狂汗，问了侄子半天，标准答案大概是，π是一个在数学及物理学领域普遍存在的数学常数……</p><p>如果你也觉得这种教育很无耻，就请转发吧，让更多的人来参与呼吁改变，为了孩子为了国家的未来……别让孩子聪明伶俐地进去呆若木鸡地出来！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/public/static/images/崔永元/别再让孩子聪明伶俐地进去呆若木鸡地出来/1.jpg&quot; alt=&quot;Image text&quot;&gt;&lt;br&gt;作者：崔 永 元&lt;/p&gt;
&lt;p&gt;侄子在读高二，考了一道历史题：成吉思汗的继承人窝阔台，公元哪一年死？最远打
      
    
    </summary>
    
      <category term="崔永远" scheme="http://ioext.com/categories/%E5%B4%94%E6%B0%B8%E8%BF%9C/"/>
    
      <category term="热门" scheme="http://ioext.com/categories/%E5%B4%94%E6%B0%B8%E8%BF%9C/%E7%83%AD%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>崔永元举报北京朝阳分局新源里派出所</title>
    <link href="http://ioext.com/2018/10/11/%E5%B4%94%E6%B0%B8%E5%85%83:%20%E4%B8%BE%E6%8A%A5%E5%8C%97%E4%BA%AC%E6%9C%9D%E9%98%B3%E5%88%86%E5%B1%80%E6%96%B0%E6%BA%90%E9%87%8C%E6%B4%BE%E5%87%BA%E6%89%80/"/>
    <id>http://ioext.com/2018/10/11/崔永元: 举报北京朝阳分局新源里派出所/</id>
    <published>2018-10-11T11:41:18.000Z</published>
    <updated>2018-10-11T03:41:50.098Z</updated>
    
    <content type="html"><![CDATA[<p>关于对北京朝阳分局新源里派出所执法敷衍不作为的举报与抗议</p><p>举  报 人：中国传媒大学教授 崔永元</p><p>被 举 报 人：北京市公安局朝阳分局新源里派出所</p><p>负   责  人：槐  杰      所  长</p><p>住       址：北京市朝阳区新源里17号</p><p>电       话：010-64674294</p><p>致北京市公安局警务督察总队：</p><p>自2013年起，本人因反对转基因滥种、揭发范冰冰冯小刚华谊兄弟偷逃税等义举，遭到相关利益集团和水军的无耻漫骂诬蔑污辱。直至发展到赤祼裸地人身安全受到威胁。留学海外的女儿信息被公开，安全无保障。本人为中华人民共和国公民，相信法律机关，相信法律公平公正。相继向公安机关报䅁：退役军人徐勇凌威胁鼓动杀人案、黄毅清严重侵犯隐私案、黄毅清诬告陷害案等刑事案件及新近发生的网民“老369”严重诽谤案。到目前为止，只有退役军人徐勇凌威胁杀人案以警局调解我善意原谅做了了结。而反映的其他问题迟迟未予答复、立案受理，违法犯罪嫌疑人黄毅清、“老369”等居然以天为单位每天污辱诽谤威胁。特别提醒警方是每一天。我想，这样的心理压力和思想压力绝大部份正常人都无法承受。但是新源里派出所和相关干警很能承受，嘴巴说得热闹，像哄孙子一样。</p><p>具体事实如下：</p><p>1、 举报人报案案情介绍</p><p>（一）徐勇凌恐吓、威胁案</p><p>举报人是新浪微博实名认证用户“崔永元”的使用者，自2018年5月下旬起，举报人因揭露娱乐圈明星阴阳合同、天价报酬、逃税偷税等一系列问题，引起了社会的广泛关注。</p><p>徐勇凌为新浪微博实名认证用户“徐勇凌”（改名之前昵称为“国际试飞员徐勇凌”）、“徐勇凌先生”的使用者。2018年6月起，徐勇凌通过“国际试飞员徐勇凌”账户，多次发布威胁、辱骂举报人的微博内容，带有“崔阳寿不多了”、“和我斗，黑道白道都不是个”、“人人可击毙疯狗崔永元”等字眼，恐吓、威胁、侮辱举报人。</p><p>我报案后，新源里派出所干警出面调解。其实徐勇凌行为已构成犯罪，但考虑到他是退伍军人会影响部队形象，本人认可了调解。2018年8月3日，徐勇凌通过“徐勇凌先生”账号公开向我致歉，但仅仅过了一天就将此致歉信删除。经本人查询，徐勇凌威胁、辱骂举报人的账户“国际试飞员徐勇凌”拥有550万粉丝数，而其道歉的“徐勇凌先生”只有粉丝数88人。通过如此低劣的阳奉阴违的手段，可见徐勇凌道歉的态度毫无诚意。很快，徐勇凌又继续于2018年8月31日通过“徐勇凌”账户发布相关辱骂内容，不是第二次，而是第二轮。</p><p>（二）黄毅清泄露隐私、诬告陷害、寻衅滋事案</p><p>黄毅清为新浪微博实名认证用户“AndyHYQ”、“黄·毅清”的使用者，自2018年6月18日起，黄毅清开始在其实名认证的微博账户“AndyHYQ”、“黄·毅清”连续发表多篇微博，捏造我联手红通人员施建祥诈骗上海百姓钱款，还捏造我协助施建祥外逃。(相关诽谤证据附后），后又捏造我有四个情人和一个私生子等不实内容（相关诽谤证据附后），除此之外，黄毅清在2018年9月8日故意曝光了我女儿的姓名、照片、留学城市等隐私信息。这严重扰乱本人和无辜受牵连的其他人的正常生活，被无辜拖累女士不堪污辱身心疲惫，有的患心脏病抑郁症，有的甚至萌生了自杀的念头。2018年9月11日，黄毅清自知闯大祸已难以收场，竟然耍苦肉计捏造我对其下毒造成他中毒昏迷经医生抢救脱险的不实内容，并称已向有关部门报案，这是十足的诬告陷害。</p><p>黄毅清是拥有350余万粉丝的网络大V级别的微博用户，始终如幽灵一般缠着我和家人、友人。每天都发送侮辱、诽谤本人、本人家人、本人友人的微博内容。黄毅清手段低级下流，每次发布内容后不久即删除相关内容，这也是他发明的逃避手段一一让受害人来不及公证证据。但每次都会形成大量转发。许多不明真相的围观群众因此对本人误解并参与谩骂、侮辱。做为当事人，本人无比愤怒多次失去理智。但思来想去也只能压制仇恨情绪，依法办事，做合格公民。黄毅清的行为已触犯刑法规定，构成刑事犯罪，理应依法追究刑事责任。</p><p>（三）“老369”诽谤、侮辱案</p><p>自2018年8月18日起，新浪微博用户“老369”通过其微博账户，发布关于我的不实图文信息。一是重复黄毅清恶意诽谤我与红通犯共同犯罪的所谓内情二是婚外情和私生子的虚假事实。文中大量使用“精神病患者”、“流氓”、“叫兽”、“骗子”、“疯”等下流、低俗的词汇辱骂举报人，甚至以举报人妻子及女儿的口吻发布了文章《我的精神病丈夫》、《我的精神病爸爸》侮辱、嘲讽举报人。“老369”的行为依治安管理处罚法，应依法对其实施行政处罚。</p><p>二、公安机关不作为的恶劣事实</p><p>针对徐勇凌、黄毅清及“老369”的前述违法犯罪事实，本人和本人委派的律师分别于2018年7月、2018年9月10日、2018年9月12日、2018年9月19日和2018年9月26日等多次到管理本人住所地的新源里派出所报案，并将相关证据提交给了办案人员。</p><p>本人压力重重已经两次重病住院却自始至终遵法守法，坚持通过正当法律途径维权，始终对法律充满信心。</p><p>令人没有想到的是，新源里派出所乃至朝阳分局对本人举报的这些案件无所用心消极应对。如，每次去报案，办案人员均以要请示上级为由让等待，最长一次等待5个多小时才做笔录。在笔录过程中，发现警员对网络环境非常陌生，跟他们描述个事情要费吃奶的劲儿，还时常表现出不耐烦。此外，每次询问案件进展时，均被以各种借口打发、拖延。其中一名承办民警房子豪甚至宣称去了上海“找不到黄毅清”。你们能不能稍微有点职业感？一名警察这样描述自己的工作不觉得像个饭桶？顺便讲个笑话，我在海淀法院刑事自诉黄毅清，海淀法院也说找不到。我能不能告诉你们，我找得到，很容易，我找来交给你们好不好？</p><p>根据《公安部关于改革完善受案立案制度的意见》规定，刑事案件立案审查期限原则上不超过3日；涉嫌犯罪线索需要查证的，立案审查期限不超过7日；重大疑难复杂案件，经县级以上公安机关负责人批准，立案审查期限可以延长至30日。请问，你们想用多少日？</p><p>这就是执法为民？我认为，徐勇凌黄毅清之所以在网络上这样流氓这样猖狂和你们的呵护是分不开的。徐犯罪了，你们鼓励我宽容，黄犯罪了，你们找不着，让他大摇大摆随意作恶。一个公民，人身安全没保障，他的女儿，人身安全受威胁，他的朋友无辜受辱以泪洗面……在你们眼里你们心里无足轻重。曾经警局告诉我：你是名人，是大学教授，是政协委员，所以上级领导很重视。请你们描述一下以上作为哪个算重视？退一万步讲，我这个算重视，老百姓就真是告状无门忍气吞声地活着。</p><p>三、我的请求</p><p>恳请贵部门查明本案事实，督促北京市公安局朝阳分局及新源里派出所尽快进行立案审查，还守法公民以公道，装也要装出积极作为的样子，给中国法律一点面子。</p><p>不要认为自己手里有点权利就可以随心所欲。有一天，你们也会希望得到法律的救援、希望社会正义、希望家人幸福平安，当你面对的是像你们一样素质的执法者，你们也会绝望。这样事情发生的概率不会低。</p><p>守法公民对社会绝望被逼上梁山者古以有之，守法公民被迫以违法方式维护自己尊严的更是不鲜见。那是黄毅清们狗娘养的犯罪分子逼的，也是你们这些手握公权力坚持不作为的执法机构逼的。</p><p>公民崔永元向你们表示严正抗议！</p><p>本文将同时刊登在海外媒体上。</p><p>举报人：崔永元</p><p>2018年   10月   10日</p><p>附：</p><p>1.受案回执：2018年9月10日 京公朝（新）受案字[2018]000432号</p><p>2.受案回执：2018年9月12日 京公朝（新）受案字[2018]000434号</p><p>3.受案回执：2018年9月26日 京公朝（新）受案字[2018]000469号</p><p>4.受案登记表：2018年9月26日 京公朝（新）受案字[2018]000469号​​​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于对北京朝阳分局新源里派出所执法敷衍不作为的举报与抗议&lt;/p&gt;
&lt;p&gt;举  报 人：中国传媒大学教授 崔永元&lt;/p&gt;
&lt;p&gt;被 举 报 人：北京市公安局朝阳分局新源里派出所&lt;/p&gt;
&lt;p&gt;负   责  人：槐  杰      所  长&lt;/p&gt;
&lt;p&gt;住       址：北
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>可以管理时间的二叉堆</title>
    <link href="http://ioext.com/2017/12/14/%E5%8F%AF%E4%BB%A5%E7%AE%A1%E7%90%86%E6%97%B6%E9%97%B4%E7%9A%84%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>http://ioext.com/2017/12/14/可以管理时间的二叉堆/</id>
    <published>2017-12-13T16:28:24.000Z</published>
    <updated>2017-12-14T04:31:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面试官：写一个堆排吧<br>我心想：堆排是什么鬼😳</p></blockquote><p>理解堆排，首先要理解二叉堆。理解了二叉堆的“下沉”操作，基本上就可以理解堆排了。今天我们来看一看什么是堆，以及堆的一般操作</p><h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><blockquote><p>近日，谦子遇到了烦心事，于是找老师去诉苦了</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/1.jpeg" alt=""></p><blockquote><p>谦子列了几个要做的事</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/2.jpeg" alt="">  </p><blockquote><p>谦子道出了心中的苦  </p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/3.jpeg" alt="">   </p><blockquote><p>谦子两眼发光</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/4.jpeg" alt=""></p><blockquote><p>克顺手画了一个图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/5.jpeg" alt=""></p><ul><li>优先级队列中每个元素都有优先级</li><li>优先级最高的最先被处理</li></ul><h1 id="优先级队列的实现"><a href="#优先级队列的实现" class="headerlink" title="优先级队列的实现"></a>优先级队列的实现</h1><p><img src="/public/static/images/可以管理时间的二叉堆/6.jpeg" alt=""> </p><blockquote><p>谦子非常想知道黑盒里面是什么  </p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/7.jpeg" alt=""> </p><blockquote><p>克非常善于引导学生思考</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/8.jpeg" alt=""> </p><blockquote><p>谦子想了想说</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/9.jpeg" alt=""> </p><blockquote><p>谦子说着说着画了一个图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/10.jpeg" alt=""></p><blockquote><p>谦子画了一幅图解释道</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/11.jpeg" alt=""></p><blockquote><p>随后，谦子又画出了插入6后的图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/12.jpeg" alt=""></p><blockquote><p>克还是不满意</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/13.jpeg" alt=""></p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><img src="/public/static/images/可以管理时间的二叉堆/14.jpeg" alt=""></p><ul><li>这里我们只讨论二叉堆，把二叉堆称为堆</li><li>堆也有d-堆，左式堆等等</li></ul><p><img src="/public/static/images/可以管理时间的二叉堆/15.jpeg" alt=""></p><blockquote><p>克看谦子不是很明白，顺手画了个图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/16.jpeg" alt=""></p><blockquote><p>克画了一个二叉堆实例</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/17.jpeg" alt=""></p><blockquote><p>注意: 二叉堆中两个孩子之前的大小没有关系，可能左孩子&gt;=右孩子，也可能右&gt;=左</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/18.jpeg" alt=""></p><blockquote><p>克随手画了一个小根堆和一个大根堆</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/19.jpeg" alt=""></p><blockquote><p>本文讨论小根堆</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/20.jpeg" alt=""></p><p><img src="/public/static/images/可以管理时间的二叉堆/21.jpeg" alt=""></p><h1 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h1><p><img src="/public/static/images/可以管理时间的二叉堆/22.jpeg" alt=""></p><ul><li>每个父节点的值小于等于其左右孩子的值被称为堆的有序性</li><li>另一种情况是大于等于也称之为堆的有序性</li></ul><blockquote><p>克随手画了一个插入操作破坏堆有序性的图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/23.jpeg" alt=""></p><blockquote><p>如何调整，谦子心里想</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/24.jpeg" alt=""></p><blockquote><p>上浮这个词形象生动，谦子心里想</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/25.jpeg" alt=""></p><blockquote><p>说完，克飞速地写出了上浮的代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  如果待插入的元素小于其父,则交换子和父,并继续上浮,知道大于等于其父</span><br><span class="line"> *  @param arr 存储堆的数组,元素从下标 1 开始有效, 0 位置不存有效值</span><br><span class="line"> *  @param inserted 被插入节点的索引</span><br><span class="line">*/</span><br><span class="line">public void swim(int[] arr, int inserted)</span><br><span class="line">&#123;</span><br><span class="line">    int parent = inserted/2; // 求出带插入元素父节点的索引</span><br><span class="line">    if( arr[inserted] &lt; arr[parent] )</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr,inserted,parent); //交换arr[inserted]和arr[parent]</span><br><span class="line">        swim(arr,parent);//交换后继续上浮</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>谦子暗自惊叹老师的代码功力</p></blockquote><h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><p><img src="/public/static/images/可以管理时间的二叉堆/26.jpeg" alt=""></p><blockquote><p>谦子听完此话紧张的手心出汗，但还是硬着头皮想了想，突然灵光一现</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/27.jpeg" alt=""></p><blockquote><p>随后谦子画出了交换后的图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/28.jpeg" alt=""><br><img src="/public/static/images/可以管理时间的二叉堆/29.jpeg" alt=""><br><img src="/public/static/images/可以管理时间的二叉堆/30.jpeg" alt=""><br><img src="/public/static/images/可以管理时间的二叉堆/31.jpeg" alt=""></p><blockquote><p>谦子刚松了口气，谁知还要写代码，只见谦子想了想，写写擦擦好几遍最终写下了如下代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  对以arr[parentIndex]为父节点的堆进行调整(下沉)</span><br><span class="line"> *  在父节点、左右孩子中选出最小节点,如果最小节点不是父节点则交换</span><br><span class="line"> *  继续下沉,反之不下沉</span><br><span class="line"> *  @param arr 要调整的数组</span><br><span class="line"> *  @param parentIndex 父节点的索引</span><br><span class="line">*/</span><br><span class="line">private void sink(int[] arr, int parentIndex)</span><br><span class="line">&#123;</span><br><span class="line">    //堆的大小,第0个位置无效元素</span><br><span class="line">    int heapSize = arr.length-1;</span><br><span class="line">    //从父节点、左孩子和右孩子中选出最小节点,得其索引</span><br><span class="line">    int minNodeIndex = minIndex(arr,parentIndex,heapSize);</span><br><span class="line">    //如果最小节点的索引不是父节点,则说明最小节点在左右孩子中,交换并继续下沉</span><br><span class="line">    if( minNodeIndex != parentIndex )</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr,minNodeIndex,parentIndex);</span><br><span class="line">        sink(arr,minModeIndex);//交换后继续下沉</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/public/static/images/可以管理时间的二叉堆/32.jpeg" alt=""></p><blockquote><p>谦子解释道，并画了一个图</p></blockquote><p><img src="/public/static/images/可以管理时间的二叉堆/33.jpeg" alt=""></p><blockquote><p>只见谦子又写了一段代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  求得给定的三个节点的最小节点的索引</span><br><span class="line"> *  @param parentIndex 父节点的索引</span><br><span class="line"> *  @param heapSize 堆的大小</span><br><span class="line"> *  @return 最小节点的索引</span><br><span class="line">*/</span><br><span class="line">private int minIndex(int[] arr,int parentIndex,int heapSize)</span><br><span class="line">&#123;</span><br><span class="line">    int minIndex = parentIndex;//保存最小节点的下标,初始时认为父节点最小</span><br><span class="line">    int leftIndex = leftIndex(parentIndex);//找到parentIndex的左孩子下标</span><br><span class="line">    //如果leftIndex没有越界,比较左孩子和父节点,选较小的Node的下标赋给minIndex</span><br><span class="line">    if(leftIndex &lt;= heapSize)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = arr[leftIndex] &lt; arr[parentIndex] ? leftIndex : parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    int rightIndex = rightIndex(parentIndex);</span><br><span class="line">    if( rightIndex &lt;= heapSize)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = arr[rightIndex] &lt; arr[minIndex] ? rightIndex : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    return minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>leftIndex = 2*parentIndex;</li><li>rightIndex = 2*parentIndex+1;</li></ul><p><img src="/public/static/images/可以管理时间的二叉堆/34.jpeg" alt=""></p><blockquote><p>看来以后得好好学数据结构与算法了，不然连时间都管理不好，谦子心想</p></blockquote><ul><li>此文章转载<a href="https://mp.weixin.qq.com/s/XEuLlIUnlBpMJPM_ipWptA" target="_blank" rel="noopener">可以管理时间的二叉堆.涛声依旧</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面试官：写一个堆排吧&lt;br&gt;我心想：堆排是什么鬼😳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解堆排，首先要理解二叉堆。理解了二叉堆的“下沉”操作，基本上就可以理解堆排了。今天我们来看一看什么是堆，以及堆的一般操作&lt;/p&gt;
&lt;h1 id=&quot;优先
      
    
    </summary>
    
    
      <category term="二叉堆" scheme="http://ioext.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
      <category term="堆" scheme="http://ioext.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用的数据类型以及转换函数</title>
    <link href="http://ioext.com/2017/12/11/Mysql%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <id>http://ioext.com/2017/12/11/Mysql常用的数据类型以及转换函数/</id>
    <published>2017-12-11T10:32:42.000Z</published>
    <updated>2017-12-11T02:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用的数据类型"><a href="#一、常用的数据类型" class="headerlink" title="一、常用的数据类型"></a>一、常用的数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><blockquote><p>int类型分类<br>1、 tinyint   1字节<br>2、 smallint  2字节<br>3、 mediumint 3字节<br>4、 int       4字节<br>5、 bigint    8字节</p></blockquote><blockquote><p>float 浮点数<br>  double 双精度<br>decimal 可以指定小数位  decimal(总长度，小数位长度) </p></blockquote><h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2><blockquote><p>date      日期类型<br>  datetime   日期类型<br>timestamp  时间戳  </p></blockquote><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><blockquote><p>char      不可变长度的字符串<br>  varchar   可变字符串字符串 最大长度 21845<br>text      大文本类型  长度无限制</p></blockquote><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><blockquote><p>blob    二进制流类型<br>enum 枚举 插入值时 对应的值 必须在枚举中存在</p></blockquote><h1 id="二、常用的数据库函数"><a href="#二、常用的数据库函数" class="headerlink" title="二、常用的数据库函数"></a>二、常用的数据库函数</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><blockquote><p>  CHARSET(str) //返回字串字符集<br>    CONCAT (string2 [,… ]) //连接字串<br>    INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0<br>    LCASE (string2 ) //转换成小写 oracle lower(字符串)<br>    UCase（string） //转换为大写  oracle upper(字符串)<br>    LEFT (string2 ,length ) //从string2中的左边起取length个字符 等价于  SUBSTRING(字符串,1,length);<br>    SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,<br>    LENGTH (string ) //string长度<br>    LTRIM (string2 ) //去除前端空格<br>    RTRIM (string2 ) //去除后端空格<br>    STRCMP (string1 ,string2 ) //逐字符比较两字串大小,<br>  REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_str</p></blockquote><h3 id="不经常使用"><a href="#不经常使用" class="headerlink" title="不经常使用"></a>不经常使用</h3><blockquote><p>  LOAD_FILE (file_name ) //从文件读取内容 例如 load_file(全路径);<br>    LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置  找到第一个字符串在第二个字符串的位置<br>    LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为length<br>    RPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为length<br>    REPEAT (string2 ,count ) //重复count次<br>    comress(string) 对字符串进行<br>uncomress(被压缩的字符串) 对字符串进行解压缩</p></blockquote><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><blockquote><p>ABS (number2 ) //绝对值<br>     FLOOR (number2 ) //向下取整 只保留整数位  不会四舍五入<br>     CEILING (number2 ) //向上取整 只要小数位大于0的值  整数位都进1<br>     ROUND (number [,decimals ]) //四舍五入,decimals为小数位数]<br>     FORMAT (number,decimal_places ) //保留小数位数 第二个参数是必选的<br>     RAND([seed]) //随机数<br>     MOD (numerator ,denominator ) //求余 等价于 数字%数字<br>     –不经常使用<br>     BIN (decimal_number ) //十进制转二进制<br>     CONV(number2,from_base,to_base) //进制转换<br>     HEX (DecimalNumber ) //转十六进制<br>     注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143<br>     也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19<br>     LEAST (number , number2 [,..]) //求最小值<br>POWER (number ,power ) //求指数</p></blockquote><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><blockquote><p> NOW ( ) //当前时间<br> CURRENT_DATE ( ) //当前日期  缩写 curdate()<br> CURRENT_TIME ( ) //当前时间  缩写 curtime()<br> CURRENT_TIMESTAMP ( ) //当前时间戳 定位到某一个时间点<br> //添加时间  第二个参数参数为1个值时 添加秒  参数为 时间:时间  添加小时和分钟<br> ADDTIME (date2 ,time_interval ) //将time_interval加到date2  用来<br> //formatCode的格式为  select date_format(now(),’%Y-%m-%d %H:%i:%s’);<br> DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetime<br>DATEDIFF (date1 ,date2 ) //两个日期差  结果是天数</p></blockquote><h3 id="不经常使用-1"><a href="#不经常使用-1" class="headerlink" title="不经常使用"></a>不经常使用</h3><blockquote><p>CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区<br>    DATE (datetime ) //返回datetime的日期部分<br>    DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间<br>    DATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间<br>    DAY (date ) //返回日期的天<br>    DAYNAME (date ) //英文星期<br>    DAYOFWEEK (date ) //星期(1-7) ,1为星期天<br>    DAYOFYEAR (date ) //一年中的第几天<br>    EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分<br>    MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串<br>    MAKETIME (hour ,minute ,second ) //生成时间串<br>    MONTHNAME (date ) //英文月份名<br>    SEC_TO_TIME (seconds ) //秒数转成时间<br>    STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示<br>    TIMEDIFF (datetime1 ,datetime2 ) //两个时间差<br>    TIME_TO_SEC (time ) //时间转秒数]<br>    WEEK (date_time [,start_of_week ]) //第几周<br>    YEAR (datetime ) //年份<br>    DAYOFMONTH(datetime) //月的第几天<br>    HOUR(datetime) //小时<br>    LAST_DAY(date) //date的月的最后日期<br>    MICROSECOND(datetime) //微秒<br>    MONTH(datetime) //月<br>    MINUTE(datetime) //分返回符号,正负或0<br>SQRT(number2) //开平方</p></blockquote><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><blockquote><p>convert(expression,type)<br>  select convert(now(),char);<br>cast(expression as type) 转换类型  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、常用的数据类型&quot;&gt;&lt;a href=&quot;#一、常用的数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、常用的数据类型&quot;&gt;&lt;/a&gt;一、常用的数据类型&lt;/h1&gt;&lt;h2 id=&quot;数字类型&quot;&gt;&lt;a href=&quot;#数字类型&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://ioext.com/tags/mysql/"/>
    
      <category term="数据类型装换" scheme="http://ioext.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A3%85%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法--插入排序改进--二分插入排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法-插入排序改进-二分插入排序/</id>
    <published>2017-12-07T17:36:08.000Z</published>
    <updated>2017-12-07T10:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function InsertionSortDichotomy($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $n = count($arr);</span><br><span class="line">    for ($i=1; $i &lt; $n ; $i++) </span><br><span class="line">    &#123; </span><br><span class="line">       $get = $arr[$i];         //右手抓到一张扑克</span><br><span class="line">       $left = 0;               // 拿在左手上的牌总是排序好的，所以可以用二分法</span><br><span class="line">       $right = $i - 1;         //手牌左右边界进行出初始化</span><br><span class="line"></span><br><span class="line">       while ( $left &lt;= $right) </span><br><span class="line">       &#123;</span><br><span class="line">           $mid =floor(($left+$right) / 2);</span><br><span class="line">           if( $arr[ $mid ] &gt; $get )</span><br><span class="line">           &#123;</span><br><span class="line">                $right = $mid - 1;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">                $left = $mid + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for ($j=$i-1; $j &gt;= $left ; $j--) //将欲插入的新牌的位置右边的牌整体向右移动一个单位</span><br><span class="line">       &#123; </span><br><span class="line">           $arr[$j+1] = $arr[$j];</span><br><span class="line">       &#125;</span><br><span class="line">       $arr[$left] = $get;              //将抓到的牌插入手牌</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分插入排序&quot;&gt;&lt;a href=&quot;#二分插入排序&quot; class=&quot;headerlink&quot; title=&quot;二分插入排序&quot;&gt;&lt;/a&gt;二分插入排序&lt;/h1&gt;&lt;p&gt;对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="http://ioext.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="二分插入排序" scheme="http://ioext.com/tags/%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--插入排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法-插入排序/</id>
    <published>2017-12-07T17:18:21.000Z</published>
    <updated>2017-12-07T09:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌</p></blockquote><p><img src="/public/static/images/插入排序/1.jpg" alt=""></p><p>对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入  </p><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间  </p><h3 id="具体算法描述如下"><a href="#具体算法描述如下" class="headerlink" title="具体算法描述如下:"></a>具体算法描述如下:</h3><blockquote><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5  </li></ol></blockquote><p>插入排序的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function InsertionSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $n = count( $arr );</span><br><span class="line">    for ($i=1; $i &lt; $n; $i++)   //类似抓扑克牌排序</span><br><span class="line">    &#123; </span><br><span class="line">        $get = $arr[$i];        //右手抓到一张扑克牌</span><br><span class="line">        $j = $i-1;              //拿在左手上的牌总是排序好的</span><br><span class="line">        while( $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $get )//将抓到的牌与手牌从右向左进行比较</span><br><span class="line">        &#123;</span><br><span class="line">            $arr[ $j+1 ] = $arr[$j];//如果该手牌比抓到的牌大，就将其右移</span><br><span class="line">            $j --;</span><br><span class="line">        &#125;</span><br><span class="line">        $arr[$j+1] = $get;      //直到该手牌比抓到的牌小(或者二者相等)，将抓到的牌插入到该手牌的右边(相等元素的相对次序未变，所以插入排序是稳定的)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下</p><p><img src="/public/static/images/插入排序/2.gif" alt=""></p><p>使用插入排序为一列数字进行排序的宏观过程:</p><p><img src="/public/static/images/插入排序/3.gif" alt=""></p><blockquote><p>注意:插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="http://ioext.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--选择排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法-选择排序/</id>
    <published>2017-12-07T16:47:47.000Z</published>
    <updated>2017-12-07T09:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：</p><blockquote><p>1、初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列； </p></blockquote><blockquote><p>2、然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</p></blockquote><blockquote><p>3、以此类推，直到所有元素均排序完毕</p></blockquote><p>注意选择排序与冒泡排序的区别：</p><blockquote><p>1、冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；</p></blockquote><blockquote><p>2、而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function SelectionSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $n = count( $arr );</span><br><span class="line">    //此循环控制走的次数</span><br><span class="line">    //此循环用来控制每一次要从中找到最大值的数据的个数</span><br><span class="line">    //也可以理解为下标范围：从0到$n-$i-1</span><br><span class="line">    //接下来，要从0到$n-$i-1范围内找到最大的那个</span><br><span class="line">    for ($i =0; $i &lt; $n-1; $i ++) </span><br><span class="line">    &#123; </span><br><span class="line">        //用于存储最大值</span><br><span class="line">       $max = $arr[0];</span><br><span class="line">       //用于存储最大值的下标，初始化为第一的下标</span><br><span class="line">       $max_pos = 0;</span><br><span class="line"></span><br><span class="line">       for ($k =0; $k &lt; $n-$i ; $k ++) </span><br><span class="line">       &#123; </span><br><span class="line">           if( $arr[$k] &gt; $max )</span><br><span class="line">           &#123;</span><br><span class="line">                $max = $arr[$k];</span><br><span class="line">                $max_pos = $k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //以上找到最大值的位置 $max_pos</span><br><span class="line">       //也就是说，这些单元中的最后一个单元的位置是 $n-$i-1</span><br><span class="line">       $tmp = $arr[$max_pos];</span><br><span class="line">       $arr[$max_pos] = $arr[$n-$i-1];</span><br><span class="line">       $arr[$n-$i-1] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SelectionSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $n = count( $arr );</span><br><span class="line">    //i为已排序序列的末尾</span><br><span class="line">    for ($i =0; $i &lt; $n-1; $i ++) </span><br><span class="line">    &#123; </span><br><span class="line">       $min = $i;</span><br><span class="line">       //未排序序列</span><br><span class="line">       for ($j= $i+1 ; $j &lt; $n; $j++) </span><br><span class="line">       &#123; </span><br><span class="line">            //找到为排序序列的最小值</span><br><span class="line">           if( $arr[$j] &lt; $arr[$min] )</span><br><span class="line">           &#123;</span><br><span class="line">                $min = $j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if( $min != $i )</span><br><span class="line">       &#123;</span><br><span class="line">            $tmp = $arr[$i];</span><br><span class="line">            $arr[$i] = $arr[$min];</span><br><span class="line">            $arr[$min] = $tmp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码对序列[ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 ]进行选择排序的实现过程如图</p><p><img src="/public/static/images/选择排序/1.gif" alt=""></p><p>使用选择排序为一列数字进行排序的宏观过程:</p><p><img src="/public/static/images/选择排序/2.gif" alt=""></p><blockquote><p>选择排序是不稳定的排序算法，不稳定发生在最小元素与$arr[i]交换的时刻<br>比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;p&gt;选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、初始时在序列中找到
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="选择排序" scheme="http://ioext.com/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--冒泡排序改进--鸡尾酒排序</title>
    <link href="http://ioext.com/2017/12/08/%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B-%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/08/算法-冒泡排序改进-鸡尾酒排序/</id>
    <published>2017-12-07T16:29:35.000Z</published>
    <updated>2017-12-07T08:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h1><p>鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function BubbleSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $left = 0;                //初始化边界</span><br><span class="line">    $right = count( $arr )-1;</span><br><span class="line">    while( $left &lt; $right )</span><br><span class="line">    &#123;</span><br><span class="line">        //前半轮，将最大元素放到后面</span><br><span class="line">        for ($i=$left; $i &lt; $right ; $i++)  </span><br><span class="line">        &#123; </span><br><span class="line">            if( $arr[$i] &gt; $arr[$i+1] )</span><br><span class="line">            &#123;</span><br><span class="line">                $tmp = $arr[$i+1];</span><br><span class="line">                $arr[ $i+1 ] = $arr[$i];</span><br><span class="line">                $arr[ $i ] = $tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $right --;</span><br><span class="line"></span><br><span class="line">        // 后半轮,将最小元素放到前面</span><br><span class="line">        for ($i=$right; $i &gt; $left ; $i--) </span><br><span class="line">        &#123; </span><br><span class="line">            if( $arr[ $i-1 ] &gt; $arr[$i] )</span><br><span class="line">            &#123;</span><br><span class="line">                $tmps = $arr[ $i-1 ];</span><br><span class="line">                $arr[$i-1] = $arr[$i];</span><br><span class="line">                $arr[$i] = $tmps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $left++;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用鸡尾酒排序为一列数字进行排序的过程如下图所示:</p><p><img src="/public/static/images/冒泡排序-鸡尾酒排序/1.gif" alt=""></p><blockquote><p>注意: 以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;鸡尾酒排序&quot;&gt;&lt;a href=&quot;#鸡尾酒排序&quot; class=&quot;headerlink&quot; title=&quot;鸡尾酒排序&quot;&gt;&lt;/a&gt;鸡尾酒排序&lt;/h1&gt;&lt;p&gt;鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="冒泡排序" scheme="http://ioext.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="鸡尾酒排序" scheme="http://ioext.com/tags/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--冒泡排序</title>
    <link href="http://ioext.com/2017/12/07/%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://ioext.com/2017/12/07/算法-冒泡排序/</id>
    <published>2017-12-07T15:57:01.000Z</published>
    <updated>2017-12-07T08:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。  </p></blockquote><blockquote><p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function BubbleSort($arr) </span><br><span class="line">&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    //设置一个空数组 用来接收冒出来的泡</span><br><span class="line">    //该层循环控制 需要冒泡的轮数</span><br><span class="line">    for ($i = 1; $i &lt; $len; $i++) </span><br><span class="line">    &#123;</span><br><span class="line">        //该层循环用来控制每轮 冒出一个数 需要比较的次数,-$i是次数减少$i</span><br><span class="line">        for ($k = 0; $k &lt; $len - $i; $k++) </span><br><span class="line">        &#123;</span><br><span class="line">            //从小到大排序</span><br><span class="line">            if ($arr[$k] &gt; $arr[$k + 1]) </span><br><span class="line">            &#123;</span><br><span class="line">                $tmp = $arr[$k + 1];</span><br><span class="line">                $arr[$k + 1] = $arr[$k];</span><br><span class="line">                $arr[$k] = $tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用冒泡排序算法，其基本原理如下:  </p><ol><li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置.</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol></blockquote><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下</p><p><img src="/public/static/images/冒泡排序/1.gif" alt=""></p><p>使用冒泡排序为一列数字进行排序的过程如下图所示：</p><p><img src="/public/static/images/冒泡排序/2.gif" alt=""></p><blockquote><p>注意: 尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。  &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://ioext.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="冒泡排序" scheme="http://ioext.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>递推(迭代)算法--递推算法</title>
    <link href="http://ioext.com/2017/12/06/%E9%80%92%E6%8E%A8(%E8%BF%AD%E4%BB%A3)%E7%AE%97%E6%B3%95--%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://ioext.com/2017/12/06/递推(迭代)算法--递推算法/</id>
    <published>2017-12-06T12:17:48.000Z</published>
    <updated>2017-12-07T06:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h1><p>要求某个“大”问题，先获得该大问题的同类问题的“最小问题”的结果，然后，如果能够通过最小问题的结果，根据一个“简单算法”而获得比该最小问题“大一级”问题的结果，则就可以根据该规律，一次次持续获得“更大一级”问题的结果，直到“碰到”最大的问题的结果，也就最终的问题结果。  </p><p>举例:<br>1、求5的阶乘:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$qian = 1;                      //1的阶乘,也是&quot;前一个数&quot;的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 2;               //2的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 3;               //3的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘,为什么?</span><br><span class="line">                                //因为,后再往后的代码可能还需要继续使用这个当做前一个数来用</span><br><span class="line"></span><br><span class="line">$hou = $qian * 4;               //4的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line">$hou = $qian * 5;               //5的阶乘,也是&quot;后一个数&quot;的阶乘</span><br><span class="line">    $qian = $hou;               //将&quot;刚刚&quot;取得的后一个数的阶乘,当做前一个数的阶乘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以上代码的含义,使用循环来完成,就是:</span><br><span class="line">$qian = 1;</span><br><span class="line">for( $i=2; $i&lt;=5; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $hou = $qian * $i;</span><br><span class="line">        $qian = $hou;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;5的阶乘:&quot;.$hou;</span><br></pre></td></tr></table></figure></p><p>在分析一个:求斐波那契数列的第20项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//例子:1,1,2,3,5,8,13,23...</span><br><span class="line">$n1 = 1;        //第一项,也可以认为:第n-2项</span><br><span class="line">$n2 = 1;        //第二项,也可以任务:第n-1项</span><br><span class="line"></span><br><span class="line">for( $i=3; $i&lt;20; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $result = $n1+$n2;</span><br><span class="line">    //即:如果,i=3,此时就得到第3项是:2;</span><br><span class="line">    //也就是现在的数列为:1,1,2</span><br><span class="line">    //在往下思考,如果要求第4项,则怎么办?如下:</span><br><span class="line">    $n = $n2;</span><br><span class="line">    $n2 = $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $result;</span><br></pre></td></tr></table></figure></p><p>再分析一个:<br>数列如:【1】,【2】,3,,6,9,18,27…<br>规律:第n个数是第n-2个数的3倍,已知第一个是1,第二个是2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$n1 = 1;</span><br><span class="line">$n2 = 2;</span><br><span class="line"></span><br><span class="line">for( $i=3; $i &lt;= 20; ++$i )</span><br><span class="line">&#123;</span><br><span class="line">    $result = $n1*3;//一般规律:当签要求的结果,是第n-2个数的结果乘以3</span><br><span class="line">    $n1 = $n2;      //将一般规律中所需要的&quot;前面数据&quot;预先准备好,以供下一次可能所需</span><br><span class="line">    $n2 = $result;</span><br><span class="line">&#125;</span><br><span class="line">echo $result;</span><br></pre></td></tr></table></figure></p><h3 id="递推算法一般规律"><a href="#递推算法一般规律" class="headerlink" title="递推算法一般规律"></a>递推算法一般规律</h3><p>递推算法通常是用循环来实现，跟函数没有直接关系（虽然也可以写在函数中），其基本模式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$n1 = 某个已知；//并且当做“前一个数据”</span><br><span class="line">for( $i = 第2个；  $i &lt;= 最终n个；  ++$i)</span><br><span class="line">&#123;</span><br><span class="line">    $result  = 对 $n1 进行一个简单计算；</span><br><span class="line">    $n1 = $result;//将已经求得的当前结果值，当做“前一个数据”以供下一次使用！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/public/static/images/递推算法/1.jpg" alt="">  </p><blockquote><p>特别注意:<br> 如果一个问题，既能够用递归算法完成，也能够用递推算法完成，则推荐使用递推算法！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递推算法&quot;&gt;&lt;a href=&quot;#递推算法&quot; class=&quot;headerlink&quot; title=&quot;递推算法&quot;&gt;&lt;/a&gt;递推算法&lt;/h1&gt;&lt;p&gt;要求某个“大”问题，先获得该大问题的同类问题的“最小问题”的结果，然后，如果能够通过最小问题的结果，根据一个“简单算法”而获
      
    
    </summary>
    
    
      <category term="递推算法" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    
      <category term="迭代算法" scheme="http://ioext.com/tags/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://ioext.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="递推" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>递推(迭代)算法--递归算法</title>
    <link href="http://ioext.com/2017/12/06/%E9%80%92%E6%8E%A8(%E8%BF%AD%E4%BB%A3)%E7%AE%97%E6%B3%95--%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <id>http://ioext.com/2017/12/06/递推(迭代)算法--递归算法/</id>
    <published>2017-12-06T11:06:13.000Z</published>
    <updated>2017-12-07T06:30:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>面对一个大问题（假设为n级问题），如果能够知道ｎ－１级问题的答案，那么就可以轻松求得ｎ级问题的答案，那么此时，我们就可以使用递归算法来解决该问题——按此思路，就可以推论到一个“最小问题”（假设为1级），此时应就是一个已知答案。则该问题就可解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function  digui( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if(  $n == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return  已知答案；</span><br><span class="line">    &#125;</span><br><span class="line">    $result  =  对digui( $n-1 ) 进行简单计算；</span><br><span class="line">    return  $result；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>就是在函数内部，调用自己本身的函数。该函数必须有一种能够“停止调用”的机制。该机制，被称为递归函数的“出口”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1( $n )</span><br><span class="line">&#123;</span><br><span class="line">    echo $n . &quot;&quot;;</span><br><span class="line">    $n++;</span><br><span class="line">    if( $n&lt;10 )</span><br><span class="line">    &#123;</span><br><span class="line">        f1($n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1(5);</span><br></pre></td></tr></table></figure></p><h3 id="递归函数的应用"><a href="#递归函数的应用" class="headerlink" title="递归函数的应用"></a>递归函数的应用</h3><blockquote><p>1、求一个正整数的阶乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1! = 1;                         人为设定                </span><br><span class="line">2! = 1*2;                       = (1!)*2;</span><br><span class="line">3! = 1*2*3;                     = (2!)*3;</span><br><span class="line">4! = 1*2*3*4;                   = (3!)*4;</span><br><span class="line">......</span><br><span class="line">N! = 1*2*3*...*N;               = ((N-1)!)*N;</span><br></pre></td></tr></table></figure></p></blockquote><p>现在我们假设我们做好了”一个函数(jiecheng())”,该函数能计算”N的阶乘”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function jiecheng( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if( $n == 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return $n;</span><br><span class="line">    &#125;</span><br><span class="line">    $result = jiecheng( $n-1 )*$n;</span><br><span class="line">    return $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jiecheng(5);</span><br></pre></td></tr></table></figure></p><p>研究该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//传递参数1时的情况:</span><br><span class="line">$t1 = jiecheng(1);//1的阶乘,1</span><br><span class="line"></span><br><span class="line">//传递参数2时的情况:</span><br><span class="line">$t2 = jiecheng(2);//2的阶乘,内部又一次jiecheng(1),将其结果(1)*2,相当于jiecheng(1)*2</span><br><span class="line"></span><br><span class="line">//继续啊:</span><br><span class="line">$t3 = jiecheng(3);//相当于jiecheng(2)*3,即:(jiecheng(1)*2)*3</span><br><span class="line"></span><br><span class="line">$t4 = jiecheng(4);//相当于jiecheng(3)*4,即(((jiecheng(1)*2)*3)*4)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>代码演示<br><img src="/public/static/images/递归算法/1.jpg" alt="">  </p><p>该函数调用过程如下:</p><p><img src="/public/static/images/递归算法/2.jpg" alt="">  </p><h3 id="递归函数总结"><a href="#递归函数总结" class="headerlink" title="递归函数总结"></a>递归函数总结</h3><blockquote><p>1、要求的最终的“大”问题，可以由比其“小一级”的问题的结果经过简单计算得到结论（一般规律）<br>2、则照此规则，可以一次次将“大”问题，化解为“更小一点”的问题。<br>3、在此过程中，会一次次“推论”到“最小一级问题”（特例结果）<br>4、该问题理应知道：要么题目给出，要么是“公理”。<br>5、递归算法，一定是跟“函数”有关的</p></blockquote><h3 id="一个有关阶乘的问题：为什么n-1的时候，没有退出？不是有return-1吗？"><a href="#一个有关阶乘的问题：为什么n-1的时候，没有退出？不是有return-1吗？" class="headerlink" title="一个有关阶乘的问题：为什么n=1的时候，没有退出？不是有return 1吗？"></a>一个有关阶乘的问题：为什么n=1的时候，没有退出？不是有return 1吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function  jiecheng( $n )</span><br><span class="line">&#123;</span><br><span class="line">    if( $n == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return  1;//行3</span><br><span class="line">    &#125;</span><br><span class="line">    $result = jicheng($n - 1 ) * $n;//行5</span><br><span class="line">    return  $result;</span><br><span class="line">&#125;</span><br><span class="line">$v1  = jicheng( 5 );//</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">$s1  = jiecheng(1);//此时，就在行3退出了，直接返回1给了$s1;</span><br><span class="line">$s2  = jiecheng(2);//此时，会在行5执行，但该行先要执行：jiecheng(1); 结果返回1，然后再乘以2，然后在赋值，</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归算法&quot;&gt;&lt;a href=&quot;#递归算法&quot; class=&quot;headerlink&quot; title=&quot;递归算法&quot;&gt;&lt;/a&gt;递归算法&lt;/h1&gt;&lt;p&gt;面对一个大问题（假设为n级问题），如果能够知道ｎ－１级问题的答案，那么就可以轻松求得ｎ级问题的答案，那么此时，我们就可以使用
      
    
    </summary>
    
    
      <category term="递推算法" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    
      <category term="迭代算法" scheme="http://ioext.com/tags/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://ioext.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="递推" scheme="http://ioext.com/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>一家要清退所有低端工程师的创业公司</title>
    <link href="http://ioext.com/2017/11/28/%E4%B8%80%E5%AE%B6%E8%A6%81%E6%B8%85%E9%80%80%E6%89%80%E6%9C%89%E4%BD%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8/"/>
    <id>http://ioext.com/2017/11/28/一家要清退所有低端工程师的创业公司/</id>
    <published>2017-11-28T10:15:14.000Z</published>
    <updated>2017-11-28T02:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/public/static/images/一家要清退所有低端工程师的创业公司/1.jpg" alt=""></p><ul><li>文/曲凯</li></ul><p>有这么一家创业公司，在发展早期的时候，招了大量的底层员工。  </p><h3 id="别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。"><a href="#别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。" class="headerlink" title="别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。"></a>别的公司有前端工程师、后端工程师，在这家公司里，他们统一管这些人叫低端工程师。</h3><p>后来，随着公司发展，这些低端工程师变得可有可无。这些人留下会影响公司的成本结构和报表，何况公司的工位也不够用了。</p><p>于是，管理层就找了个导火索，不顾大家建议，决定在短时间内清退所有低端工程师。</p><p>他们没想到，这些低端工程师里面，也有前端、有后端，他们的突然离开造成了一大波人的恐慌。</p><p>但管理层始终认为，做这件事是为了公司长远的发展，是造福公司中的每个人。</p><h3 id="管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。"><a href="#管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。" class="headerlink" title="管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。"></a>管理层也认为自己毕竟还是家创业公司，只要想办法维持高速增长就可以掩饰和拖延一切问题。</h3><p>但他们没想到的是，保证公司内部发展的规则和每个员工的权利，从来都不是为了让公司能快速发展，而是为了让公司能避开系统性风险，维持稳定发展。</p><p>一家创业公司早期的指数增长是靠创始人的天赋、能力、远景等等，这个时候如果过于被世俗规则牵绊，反而不是好事。</p><p>但所有公司后期的维系还是要靠规则，这个时候如果还是靠少数人的直觉，就会尾大不掉，遭遇深坑。</p><h3 id="所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。"><a href="#所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。" class="headerlink" title="所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。"></a>所以，创业公司要明确知道自己应该往有规则的路上走，不能放任听之。毕竟没有什么公司能一直是一家高速发展的创业公司。</h3><p>而且，其实大多打抱不平的员工，自己也没想明白这件事意味着什么。</p><p>所有留下的非低端工程师，手里都拿着公司的期权和股票，都是和公司绑定在一起的。</p><p>其实在绝大多数人眼里，留下的人都已经是名副其实的既得利益者。</p><p>今天帮低端工程师说话，其实也是站在创业公司的角度，为了让公司更好，也为了让自己更好。</p><p>不然，如果未来哪天低端工程师真的闹起来，觉得所有的底层代码都是自己写的，要把那些所谓的前端和后端工程师都拉出来批一番，要平分他们所获得的功劳，只怕没有一个人会有好日子过。</p><p>关于创业公司和裁员，去年我还写过一篇文章，也是42章经历史上唯一被强制删除的一篇，今天自我阉割后再次发在这里。毕竟过去的一周太过于魔幻现实主义，以此作为纪念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在一年前，当我还是一个投资人的时候，总觉得自己的生活被工作无缝环绕。吃饭、喝咖啡都不用说了，就连偶尔坐个地铁，旁边坐的都是在聊创业和投资的人。</span><br><span class="line"></span><br><span class="line">每次我都很想过去说：</span><br><span class="line"></span><br><span class="line">“孩子，好好上学不好吗？校园代收发快递融不到钱的。”</span><br><span class="line"></span><br><span class="line">“大叔，别做社交软件了好吗？还社群+O2O，真心都死了啊！”</span><br><span class="line"></span><br><span class="line">又过了一段时间，聊创业的人少了，聊资本寒冬的人多了。我觉得这是好事，互联网的天生垄断属性，自然让创业变成一个具有赌博性质的游戏。如果二级市场里的散户是韭菜，那么一级市场里的散户就是炮灰。韭菜割完还能长，炮灰散了就灰飞烟灭了。</span><br><span class="line"></span><br><span class="line">最近，这个趋势又开始向更有意思的方向转变了。我已经很多次在地铁上听到旁边有人在聊：</span><br><span class="line"></span><br><span class="line">“你们公司融到钱了吗？”</span><br><span class="line"></span><br><span class="line">“公司说再待久一点就要发期权，是什么意思？”</span><br><span class="line"></span><br><span class="line">“咱们公司总这么靠投资人养活也不是事啊，什么时候才能赚钱？”</span><br></pre></td></tr></table></figure></p><h3 id="一个很可怕的经济传递就这样在地铁上完成了。"><a href="#一个很可怕的经济传递就这样在地铁上完成了。" class="headerlink" title="一个很可怕的经济传递就这样在地铁上完成了。"></a>一个很可怕的经济传递就这样在地铁上完成了。</h3><p>一大波融到钱的人，招了比他们更多量级的人，然后遇到了资本寒冬，最终焦虑的是投资人和创业者，但真正付出代价的是这些创业公司的从业者们。他们甚至不懂什么是 VC、什么是期权，不懂为什么公司一直在赔钱，还一直有人给钱。但突然有一天，他们觉得自己要开始关心这些问题了，因为他们看到了身边人的窘境，与自己摇摇欲坠的未来。</p><p>可以说，  </p><h3 id="二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。"><a href="#二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。" class="headerlink" title="二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。"></a>二级市场的韭菜害的是自己，一级市场的炮灰害的是一连串人。</h3><p>所以创业者们真的不要再转发说创业有多难，做 CEO 有多难了。创业者每次看着自己的员工都应该抱有一颗感恩和敬畏的心，最难的永远是这些人。</p><p>我曾经见过凌晨一二点几个外卖员在一起抱团等单子，见过凌晨三四点同城配送的司机为了生计去仓库拉货，见过背着比人还大的包、还要拿着张床坐地铁跑很远去上门按摩的人。他们都是这个世界上最客气的人，他们进门前都要小心翼翼拿出鞋套，走的时候都要鞠个躬想要一个五星好评。</p><p>这些在城市中从早到晚穿行的外卖员、快递员、专车司机和各种互联网工作者，他们的行为和路径像极了我们城市网络中的底层搬运工。这些付出劳动养活自己的人，为什么得不到你们那么巨量的关注？其实，可能只是因为他们离你太近了。</p><p>2015 年的一项政府数据说，全国每天新成立的公司有 12000 家。那么全年就是超过 400 万家公司，假设平均每家公司只有 5 个人，也是影响到 2000 万个人，这还只是 2015 年一年。</p><p>单苏州一个二线城市，政府的目标就已经是要在 2020 年前开 300 个孵化器，对接 30000 家创业公司。而据安永的一份统计说，去年已经有 500 亿美元投进了创投市场。</p><p>你要知道，从专业投资的角度来说，如果一家公司的客户全都是初创企业或小客户，那么这代表着不稳定。政府层面引导的全民创业在短期内创造了就业，但在长期来看，供需关系的失衡几乎是一种必然。</p><p>之前有一篇标题叫《裁员！裁员！裁员！创业者们的寒冬大逃杀》的文章，在朋友圈也是被转了无数次。但大家大都从创业者和投资人的角度感慨，却很少有人问一句，被裁的人去哪了？大逃杀、大逃杀，逃的是资本方、创始人和公司，杀的是谁？</p><p>最后，故事从地铁开始，也从地铁结束好了。</p><p>以前我很讨厌坐地铁抢座的人，觉得那根本就是渺小人格才会做的事情，我才不要同流合污，所以渐渐上了地铁都不坐了，只站着旁观，看到别人抢座我在旁边就会有一种优越感。我觉得这大概和转发并评论的行为差不多，应该叫做“出世”？</p><p>但现在眼前有座的话我就会去坐下，因为这样才能自己掌握资源和主动权，才能保证在老弱妇孺上车的时候可以有人让座给他们。做好自己的事情，尽好自己的责任，为需要的人争取资源，这就应该称为“入世”吧。</p><p>“如果一个人为了钱犯罪，这个人有罪。如果一个人为了面包犯罪，这个社会有罪。”</p><p>我相信这句话本身是对的，但赎罪的方式有很多种，却绝对不仅止于转发。</p><p>最近一周里，有太多的无力感，就是因为我们能做的只有转发。</p><p>希望未来能有越来越多抢到座位的人，把座位让出来。</p><ul><li>本文转载至<a href="https://m.huxiu.com/article/223527.html" target="_blank" rel="noopener">虎嗅网·42章经</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/public/static/images/一家要清退所有低端工程师的创业公司/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文/曲凯&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有这么一家创业公司，在发展早期的时候，招了大量的底层员工。  &lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="创业" scheme="http://ioext.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="低端" scheme="http://ioext.com/tags/%E4%BD%8E%E7%AB%AF/"/>
    
      <category term="虎嗅" scheme="http://ioext.com/tags/%E8%99%8E%E5%97%85/"/>
    
      <category term="42章经" scheme="http://ioext.com/tags/42%E7%AB%A0%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则6:开闭原则</title>
    <link href="http://ioext.com/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%996-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/20/设计模式六大原则6-开闭原则/</id>
    <published>2017-10-20T15:24:20.000Z</published>
    <updated>2017-10-20T09:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p></li><li><p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p></li><li><p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p></li></ul><p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p><p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p><p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p>说到这里，再回想一下前面说的5项原则， 恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。  </p><p><img src="/public/static/images/设计模式六大原则6:开闭原则/1.gif" alt="">  </p><p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。  </p><p><img src="/public/static/images/设计模式六大原则6:开闭原则/2.gif" alt="">    </p><p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p><p>到这里，设计模式的六大原则就写完了。主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章，但主要内容主要还是我本人对这六个原则的感悟。写出来的目的一方面是对这六项原则系统地整理一下，一方面也与广大的网友分享，因为设计模式对编程人员来说，的确非常重要。正如有句话叫做一千个读者眼中有一千个哈姆雷特，如果大家对这六项原则的理解跟我有所不同，欢迎留言，大家共同探讨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需
      
    
    </summary>
    
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
      <category term="开闭原则" scheme="http://ioext.com/tags/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则5:迪米特法则</title>
    <link href="http://ioext.com/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%995-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    <id>http://ioext.com/2017/10/20/设计模式六大原则5-迪米特法则/</id>
    <published>2017-10-19T17:23:48.000Z</published>
    <updated>2017-10-20T07:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义：一个对象应该对其他对象保持最少的了解。</p></li><li><p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p></li><li><p>解决方案：尽量降低类与类之间的耦合。</p></li></ul><p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p><p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</p><p>迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//总公司员工  </span><br><span class="line">class Employee&#123;  </span><br><span class="line">    private String id;  </span><br><span class="line">    public void setId(String id)&#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getId()&#123;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//分公司员工  </span><br><span class="line">class SubEmployee&#123;  </span><br><span class="line">    private String id;  </span><br><span class="line">    public void setId(String id)&#123;  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public String getId()&#123;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class SubCompanyManager&#123;  </span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;  </span><br><span class="line">            SubEmployee emp = new SubEmployee();  </span><br><span class="line">            //为分公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class CompanyManager&#123;  </span><br><span class="line">  </span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;30; i++)&#123;  </span><br><span class="line">            Employee emp = new Employee();  </span><br><span class="line">            //为总公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();  </span><br><span class="line">        for(SubEmployee e:list1)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();  </span><br><span class="line">        for(Employee e:list2)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Client&#123;  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        CompanyManager e = new CompanyManager();  </span><br><span class="line">        e.printAllEmployee(new SubCompanyManager());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;  </span><br><span class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;100; i++)&#123;  </span><br><span class="line">            SubEmployee emp = new SubEmployee();  </span><br><span class="line">            //为分公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;分公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void printEmployee()&#123;  </span><br><span class="line">        List&lt;SubEmployee&gt; list = this.getAllEmployee();  </span><br><span class="line">        for(SubEmployee e:list)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class CompanyManager&#123;  </span><br><span class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;  </span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();  </span><br><span class="line">        for(int i=0; i&lt;30; i++)&#123;  </span><br><span class="line">            Employee emp = new Employee();  </span><br><span class="line">            //为总公司人员按顺序分配一个ID  </span><br><span class="line">            emp.setId(&quot;总公司&quot;+i);  </span><br><span class="line">            list.add(emp);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return list;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;  </span><br><span class="line">        sub.printEmployee();  </span><br><span class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();  </span><br><span class="line">        for(Employee e:list2)&#123;  </span><br><span class="line">            System.out.println(e.getId());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：一个对象应该对其他对象保持最少的了解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决方案：尽量降低类与类之间的耦合。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
      <category term="迪米特法则" scheme="http://ioext.com/tags/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则4:接口隔离原则</title>
    <link href="http://ioext.com/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%994-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/20/设计模式六大原则4-接口隔离原则/</id>
    <published>2017-10-19T17:08:33.000Z</published>
    <updated>2017-10-19T09:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p></li><li><p>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p></li><li><p>解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p></li></ul><p>举例来说明接口隔离原则：</p><p><img src="/public/static/images/设计模式六大原则4-接口隔离原则/1.jpg" alt="未遵循接口隔离原则的设计">  </p><p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">interface I </span><br><span class="line">&#123;  </span><br><span class="line">    public function method1();  </span><br><span class="line">    public function method2();  </span><br><span class="line">    public function method3();  </span><br><span class="line">    public function method4();  </span><br><span class="line">    public function method5();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class B implements I</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method2() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法2&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method3() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I的方法3&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，  </span><br><span class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span><br><span class="line">      </span><br><span class="line">    public function method4() &#123;&#125;  </span><br><span class="line">    public function method5() &#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class C</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class D implements I</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，  </span><br><span class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。  </span><br><span class="line">    public function method2() &#123;&#125;  </span><br><span class="line">    public function method3() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public function method4() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法4&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method5() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I的方法5&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $a = new A();  </span><br><span class="line">        $a-&gt;depend1(new B());  </span><br><span class="line">        $a-&gt;depend2(new B());  </span><br><span class="line">        $a-&gt;depend3(new B());  </span><br><span class="line">          </span><br><span class="line">        $c = new C();  </span><br><span class="line">        $c-&gt;depend1(new D());  </span><br><span class="line">        $c-&gt;depend2(new D());  </span><br><span class="line">        $c-&gt;depend3(new D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p><p><img src="/public/static/images/设计模式六大原则4-接口隔离原则/2.jpg" alt="遵循接口隔离原则的设计">  </p><p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">interface I1 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method1();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface I2 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method2();  </span><br><span class="line">    public function method3();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface I3 </span><br><span class="line">&#123;  </span><br><span class="line">    public function method4();  </span><br><span class="line">    public function method5();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I1 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend2(I2 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I2 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class B implements I1, I2</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I1的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method2() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I2的方法2&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method3() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类B实现接口I2的方法3&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class C</span><br><span class="line">&#123;  </span><br><span class="line">    public function depend1(I1 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method1();  </span><br><span class="line">    &#125; </span><br><span class="line">    public function depend2(I3 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function depend3(I3 $i)</span><br><span class="line">    &#123;  </span><br><span class="line">        $i-&gt;method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class D implements I1, I3</span><br><span class="line">&#123;  </span><br><span class="line">    public function method1() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I1的方法1&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method4() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I3的方法4&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public function method5() </span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;类D实现接口I3的方法5&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。</p><ul><li>其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。</li><li>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li></ul><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li><p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</p></li><li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p></li><li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p></li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方
      
    
    </summary>
    
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
      <category term="接口隔离原则" scheme="http://ioext.com/tags/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则3:依赖倒置原则</title>
    <link href="http://ioext.com/2017/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%993-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/19/设计模式六大原则3-依赖倒置原则/</id>
    <published>2017-10-19T12:22:01.000Z</published>
    <updated>2017-11-28T02:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><blockquote><p>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p></blockquote><blockquote><p>解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p></blockquote><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Mother</span><br><span class="line">&#123;  </span><br><span class="line">    public function narrate(Book $book)&#123;  </span><br><span class="line">        echo &quot;妈妈开始讲故事&quot;;  </span><br><span class="line">        echo $book-&gt;getContent(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $mother = new Mother();  </span><br><span class="line">        $mother-&gt;narrate(new Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……</p><p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。<br>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IReader</span><br><span class="line">&#123;</span><br><span class="line">    public function getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader </span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Book implements IReader</span><br><span class="line">&#123;  </span><br><span class="line">    public function getContent()</span><br><span class="line">    &#123;  </span><br><span class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Mother</span><br><span class="line">&#123;  </span><br><span class="line">    public void narrate(IReader $reader)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo &quot;妈妈开始讲故事&quot;;  </span><br><span class="line">        echo $reader-&gt;getContent();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client</span><br><span class="line">&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $mother = new Mother();  </span><br><span class="line">        $mother-&gt;narrate(new Book());  </span><br><span class="line">        $mother-&gt;narrate(new Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>妈妈开始讲故事<br>林书豪17+9助尼克斯击败老鹰……</p><p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p><p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。<br>在实际编程中，我们一般需要做到如下3点：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有。</li><li>变量的声明类型尽量是抽象类或接口。</li><li><p>使用继承时遵循里氏替换原则。</p><p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="依赖倒置" scheme="http://ioext.com/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则2:里氏替换原则</title>
    <link href="http://ioext.com/2017/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%992-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/19/设计模式六大原则2-里氏替换原则/</id>
    <published>2017-10-18T17:08:01.000Z</published>
    <updated>2017-10-19T04:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p><ul><li>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</li><li>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</li><li>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</li><li>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。<br>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。  </li></ul><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。  </p><p>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A </span><br><span class="line">&#123;</span><br><span class="line">    public function func1( $a, $b )</span><br><span class="line">    &#123;</span><br><span class="line">        return $a-$b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public function main()</span><br><span class="line">    &#123;</span><br><span class="line">        $oModel = new A();</span><br><span class="line">        $oModel-&gt;func1(100,50);</span><br><span class="line">        $oModel-&gt;func1(100,80);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br>100-50=50<br>100-80=20     </p><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加100。<br>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">    public function func1( $a, $b )</span><br><span class="line">    &#123;</span><br><span class="line">        return $a+$b;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public function func1( $a, $b )</span><br><span class="line">    &#123;</span><br><span class="line">        return func1($a,$b)+100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client</span><br><span class="line">&#123;</span><br><span class="line">    public function main()</span><br><span class="line">    &#123;</span><br><span class="line">        $oModel = new B();</span><br><span class="line">        $oModel-&gt;func1(100,50);</span><br><span class="line">        $oModel-&gt;func1(100,80);</span><br><span class="line">        $oModel-&gt;func2(100,20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>类B完成后，运行结果：<br>100-50=150<br>100-80=180<br>100+20+100=220  </p><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p><blockquote><p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。  </li></ul></blockquote><p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？  </p><p>后果就是：你写的代码出问题的几率将会大大增加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的
      
    
    </summary>
    
    
      <category term="php" scheme="http://ioext.com/tags/php/"/>
    
      <category term="设计模式" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="里氏替换原则" scheme="http://ioext.com/tags/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则1:单一职责原则</title>
    <link href="http://ioext.com/2017/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%991-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://ioext.com/2017/10/18/设计模式六大原则1-单一职责原则/</id>
    <published>2017-10-17T18:18:05.000Z</published>
    <updated>2017-10-19T03:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>定义:不要存在多于一个导致类变更的原因。通俗的说,即一个类只负责一项职责。</li><li>问题由来:类T负责两个不同的职责:职责P1,职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</li><li>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。  </li></ul><p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</p><p>比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）<br> 举例说明，用一个类描述动物呼吸这个场景：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">    public function breathe( $animal )&#123;  </span><br><span class="line">        echo $animal.&quot;呼吸空气&quot;;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main( $arg )&#123;  </span><br><span class="line">        $animal = new Animal();  </span><br><span class="line">        $animal-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $animal-&gt;reathe(&quot;羊&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>牛呼吸空气<br>羊呼吸空气<br>猪呼吸空气</p><p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Terrestrial&#123;  </span><br><span class="line">    public function breathe( $animal )&#123;  </span><br><span class="line">        echo $animal.&quot;呼吸空气&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Aquatic&#123;  </span><br><span class="line">    public function breathe( $animal)&#123;  </span><br><span class="line">        echo $animal.&quot;呼吸水&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main( $args )&#123;  </span><br><span class="line">        $terrestrial = new Terrestrial();  </span><br><span class="line">        $terrestrial-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $terrestrial-&gt;breathe(&quot;羊&quot;);  </span><br><span class="line">        $terrestrial-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">          </span><br><span class="line">        $aquatic = new Aquatic();  </span><br><span class="line">        $aquatic-&gt;breathe(&quot;鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;     </span><br><span class="line">    public function breathe($animal)</span><br><span class="line">    &#123;  </span><br><span class="line">        if(&quot;鱼&quot; == $animal))</span><br><span class="line">        &#123;  </span><br><span class="line">            echo $animal.&quot;呼吸水&quot;);  </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;  </span><br><span class="line">           echo $animal.&quot;呼吸空气&quot;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main($args)</span><br><span class="line">    &#123;  </span><br><span class="line">        $animal = new Animal();  </span><br><span class="line">        $animal-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;羊&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;  </span><br><span class="line">    public function breathe($animal)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo $animal.&quot;呼吸空气&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public function breathe2($animal)</span><br><span class="line">    &#123;  </span><br><span class="line">        echo $animal.&quot;呼吸水&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Client&#123;  </span><br><span class="line">    public function main($args)&#123;  </span><br><span class="line">        $animal = new Animal();  </span><br><span class="line">        $animal-&gt;breathe(&quot;牛&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;羊&quot;);  </span><br><span class="line">        $animal-&gt;breathe(&quot;猪&quot;);  </span><br><span class="line">        $animal-&gt;breathe2(&quot;鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；<br>        例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。<br>遵循单一职责原的优点有：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。<br>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;定义:不要存在多于一个导致类变更的原因。通俗的说,即一个类只负责一项职责。&lt;/li&gt;
&lt;li&gt;问题由来:类T负责两个不同的职责:职责P1,职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。&lt;/li&gt;
&lt;li&gt;遵
      
    
    </summary>
    
    
      <category term="php" scheme="http://ioext.com/tags/php/"/>
    
      <category term="设计模式" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单一职责" scheme="http://ioext.com/tags/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/"/>
    
      <category term="设计模式原则" scheme="http://ioext.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Laravel生命周期的核心概念</title>
    <link href="http://ioext.com/2017/10/17/Laravel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://ioext.com/2017/10/17/Laravel生命周期/</id>
    <published>2017-10-16T18:04:26.000Z</published>
    <updated>2018-10-12T09:04:01.477Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。在开发Xblog的过程中，稍微领悟了一点Laravel的思想。确实如此，这篇文章读完你可能并不能从无到有写出一个博客，但知道Laravel的核心概念之后，当你再次写起Laravel时，会变得一目了然胸有成竹.  </p><h2 id="PHP的生命周期"><a href="#PHP的生命周期" class="headerlink" title="PHP的生命周期"></a>PHP的生命周期</h2><p>万物皆有他的生命周期。熟悉Android的同学一定熟悉Android最经典的Activity的生命周期，Laravel 也不例外，Laravel应用程序也有自己的生命周期。Laravel是什么？一个PHP框架。所以要想真正说清Laravel的生命周期，必须说清PHP的生命周期。原文参考这里，这里做个总结。  </p><p>PHP有两种运行模式，WEB模式和CLI（命令行）模式。当我们在终端敲入php这个命令的时候，使用的是CLI模式；当使用Nginx或者别web服务器作为宿主处理一个到来的请求时，会调用PHP运行，此时使用的是WEB模式。当我们请求一个PHP文件时，比如Laravel 的public\index.php文件时，PHP为了完成这次请求，会发生5个阶段的生命周期切换：</p><p>1、模块初始化（MINIT），即调用php.ini中指明的扩展的初始化函数进行初始化工作，如mysql扩展。</p><p>2、请求初始化（RINIT），即初始化为执行本次脚本所需要的变量名称和变量值内容的符号表，如$_SESSION变量。</p><p>3、执行该PHP脚本。</p><p>4、请求处理完成(Request Shutdown)，按顺序调用各个模块的RSHUTDOWN方法，对每个变量调用unset函数，如unset $_SESSION变量。</p><p>5、关闭模块(Module Shutdown) ， PHP调用每个扩展的MSHUTDOWN方法，这是各个模块最后一次释放内存的机会。这意味着没有下一个请求了。  </p><p>WEB模式和CLI（命令行）模式很相似，区别是：CLI 模式会在每次脚本执行经历完整的5个周期，因为你脚本执行完不会有下一个请求；而WEB模式为了应对并发，可能采用多线程，因此生命周期1和5有可能只执行一次，下次请求到来时重复2-4的生命周期，这样就节省了系统模块初始化所带来的开销。  </p><p>可以看到，PHP生命周期是很对称的。说了这么多，就是为了定位Laravel运行在哪里，没错，Laravel仅仅运行再第三个阶段：  </p><p><img src="/public/static/images/laravel生命周期/1.png" alt="Image text">  </p><p>知道这些有什么用？你可以优化你的Laravel代码，可以更加深入的了解Larave的singleton（单例）。至少你知道了，每一次请求结束，Php的变量都会unset，Laravel的singleton只是在某一次请求过程中的singleton；你在Laravel 中的静态变量也不能在多个请求之间共享，因为每一次请求结束都会unset。理解这些概念，是写高质量代码的第一步，也是最关键的一步。因此记住，PHP是一种脚本语言，所有的变量只会在这一次请求中生效，下次请求之时已被重置，而不像Java静态变量拥有全局作用</p><p>好了，开始Laravel的生命周期。  </p><h2 id="Laravel的生命周期"><a href="#Laravel的生命周期" class="headerlink" title="Laravel的生命周期"></a>Laravel的生命周期</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Laravel 的生命周期从public\index.php开始，从public\index.php结束</p><p><img src="/public/static/images/laravel生命周期/2.png" alt="Image text">  </p><p>注意：以下几图箭头均代表Request流向  </p><p>这么说有点草率，但事实确实如此。下面是public\index.php的全部源码（Laravel源码的注释是最好的Laravel文档），更具体来说可以分为四步：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. require __DIR__.&apos;/../bootstrap/autoload.php&apos;;</span><br><span class="line"></span><br><span class="line">2. $app = require_once __DIR__.&apos;/../bootstrap/app.php&apos;;</span><br><span class="line">   $kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br><span class="line"></span><br><span class="line">3. $response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">   );</span><br><span class="line">   $response-&gt;send();</span><br><span class="line"></span><br><span class="line">4. $kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure><p>这四步详细的解释是：</p><p>1.注册加载composer自动生成的class loader，包括所有你composer require的依赖（对应代码1）.</p><p>2.生成容器Container，Application实例，并向容器注册核心组件（HttpKernel，ConsoleKernel，ExceptionHandler）（对应代码2，容器很重要，后面详细讲解）。 </p><p>3.处理请求，生成并发送响应（对应代码3，毫不夸张的说，你99%的代码都运行在这个小小的handle方法里面）。 </p><p>4.请求结束，进行回调（对应代码4，还记得可终止中间件吗？没错，就是在这里回调的）。  </p><p><img src="/public/static/images/laravel生命周期/3.png" alt="Image text"> </p><h3 id="启动Laravel基础服务"><a href="#启动Laravel基础服务" class="headerlink" title="启动Laravel基础服务"></a>启动Laravel基础服务</h3><p>第一步注册加载composer自动生成的class loader就是加载初始化第三方依赖，不属于Laravel核心，到此为止。<br>第二步生成容器Container，并向容器注册核心组件，这里牵涉到了容器Container和合同Contracts，这是Laravel的重点，下面将详细讲解。<br>重点是第三步处理请求，生成并发送响应。<br>首先Laravel框架捕获到用户发到public\index.php的请求，生成Illuminate\Http\Request实例，传递给这个小小的handle方法。在方法内部，将该$request实例绑定到第二步生成的$app容器上。让后在该请求真正处理之前，调用bootstrap方法，进行必要的加载和注册，如检测环境，加载配置，注册Facades（假象），注册服务提供者，启动服务提供者等等。这是一个启动数组，具体在Illuminate\Foundation\Http\Kernel中，包括：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected $bootstrappers = [</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\DetectEnvironment&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\LoadConfiguration&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\ConfigureLogging&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\HandleExceptions&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\RegisterFacades&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\RegisterProviders&apos;,</span><br><span class="line">    &apos;Illuminate\Foundation\Bootstrap\BootProviders&apos;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>看类名知意，Laravel是按顺序遍历执行注册这些基础服务的，注意顺序：Facades先于ServiceProviders，Facades也是重点，后面说，这里简单提一下，注册Facades就是注册config\app.php中的aliases 数组，你使用的很多类，如Auth，Cache,DB等等都是Facades；而ServiceProviders的register方法永远先于boot方法执行，以免产生boot方法依赖某个实例而该实例还未注册的现象。</p><p>所以，你可以在ServiceProviders的register方法中使用任何Facades，在ServiceProviders的boot方法中使用任何register方法中注册的实例或者Facades，这样绝不会产生依赖某个类而未注册的现象。</p><h3 id="将请求传递给路由"><a href="#将请求传递给路由" class="headerlink" title="将请求传递给路由"></a>将请求传递给路由</h3><p>注意到目前为止，Laravel 还没有执行到你所写的主要代码（ServiceProviders中的除外），因为还没有将请求传递给路由。</p><p>在Laravel基础的服务启动之后，就要把请求传递给路由了。传递给路由是通过Pipeline（另开篇章讲解）来传递的，但是Pipeline有一堵墙，在传递给路由之前所有请求都要经过，这堵墙定义在app\Http\Kernel.php中的$middleware数组中，没错就是中间件，默认只有一个CheckForMaintenanceMode中间件，用来检测你的网站是否暂时关闭。这是一个全局中间件，所有请求都要经过，你也可以添加自己的全局中间件。</p><p>然后遍历所有注册的路由，找到最先符合的第一个路由，经过它的路由中间件，进入到控制器或者闭包函数，执行你的具体逻辑代码。</p><p>所以，在请求到达你写的代码之前，Laravel已经做了大量工作，请求也经过了千难万险，那些不符合或者恶意的的请求已被Laravel隔离在外。   </p><p><img src="/public/static/images/laravel生命周期/4.png" alt="Image text"> </p><h3 id="服务容器"><a href="#服务容器" class="headerlink" title="服务容器"></a>服务容器</h3><p>服务容器就是一个普通的容器，用来装类的实例，然后在需要的时候再取出来。用更专业的术语来说是服务容器实现了控制反转（Inversion of Control，缩写为IoC），意思是正常情况下类A需要一个类B的时候，我们需要自己去new类B，意味着我们必须知道类B的更多细节，比如构造函数，随着项目的复杂性增大，这种依赖是毁灭性的。控制反转的意思就是，将类A主动获取类B的过程颠倒过来变成被动，类A只需要声明它需要什么，然后由容器提供。</p><p><img src="/public/static/images/laravel生命周期/5.png" alt="Image text">  </p><p>这样做的好处是，类A不依赖于类B的实现，这样在一定程度上解决了耦合问题。</p><p>在Laravel的服务容器中，为了实现控制反转，可以有以下两种：</p><p>依赖注入（Dependency Injection）。<br>绑定。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入是一种类型提示，举官网的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * The user repository implementation.</span><br><span class="line">     *</span><br><span class="line">     * @var UserRepository</span><br><span class="line">     */</span><br><span class="line">    protected $users;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new controller instance.</span><br><span class="line">     *</span><br><span class="line">     * @param  UserRepository  $users</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function __construct(UserRepository $users)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;users = $users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Show the profile for the given user.</span><br><span class="line">     *</span><br><span class="line">     * @param  int  $id</span><br><span class="line">     * @return Response</span><br><span class="line">     */</span><br><span class="line">    public function show($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $user = $this-&gt;users-&gt;find($id);</span><br><span class="line"></span><br><span class="line">        return view(&apos;user.profile&apos;, [&apos;user&apos; =&gt; $user]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里UserController需要一个UserRepository实例，我们只需在构造方法中声明我们需要的类型，容器在实例化UserController时会自动生成UserRepository的实例（或者实现类，因为UserRepository可以为接口），而不用主动去获取UserRepository的实例，这样也就避免了了解UserRepository的更多细节，也不用解决UserRepository所产生的依赖，我们所做的仅仅是声明我们所需要的类型，所有的依赖问题都交给容器去解决。（Xblog使用了Repository的是设计模式，大家可以参考）</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>绑定操作一般在ServiceProviders中的register方法中，最基本的绑定是容器的bind方法，它接受一个类的别名或者全名和一个闭包来获取实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;app-&gt;bind(&apos;XblogConfig&apos;, function ($app) &#123;</span><br><span class="line">    return new MapRepository();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>还有一个singleton方法，和bind写法没什么区别。你也可以绑定一个已经存在的对象到容器中，上文中提到的request实例就是通过这种方法绑定到容器的：$this-&gt;app-&gt;instance(‘request’, $request);。绑定之后，我们可以通过一下几种方式来获取绑定实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  app(&apos;XblogConfig&apos;);</span><br><span class="line"></span><br><span class="line">2.  app()-&gt;make(&apos;XblogConfig&apos;);</span><br><span class="line"></span><br><span class="line">3.  app()[&apos;XblogConfig&apos;];</span><br><span class="line"></span><br><span class="line">4.  resolve(&apos;XblogConfig&apos;);</span><br></pre></td></tr></table></figure><p>以上四种方法均会返回获得MapRepository的实例，唯一的区别是，在一次请求的生命周期中，bind方法的闭包会在每一次调用以上四种方法时执行，singleton方法的闭包只会执行一次。在使用中，如果每一个类要获的不同的实例，或者需要“个性化”的实例时，这时我们需要用bind方法以免这次的使用对下次的使用造成影响；如果实例化一个类比较耗时或者类的方法不依赖该生成的上下文，那么我们可以使用singleton方法绑定。singleton方法绑定的好处就是，如果在一次请求中我们多次使用某个类，那么只生成该类的一个实例将节省时间和空间。</p><p>你也可以绑定接口与实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Http\Kernel::class,</span><br><span class="line">    App\Http\Kernel::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上文讲述的Laravel的生命周期的第二步，Laravel默认（在bootstrap\app.php文件中）绑定了Illuminate\Contracts\Http\Kernel，Illuminate\Contracts\Console\Kernel，Illuminate\Contracts\Debug\ExceptionHandler接口的实现类，这些是实现类框架的默认自带的。但是你仍然可以自己去实现。</p><p>还有一种上下文绑定，就是相同的接口，在不同的类中可以自动获取不同的实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;app-&gt;when(PhotoController::class)</span><br><span class="line">          -&gt;needs(Filesystem::class)</span><br><span class="line">          -&gt;give(function () &#123;</span><br><span class="line">              return Storage::disk(&apos;local&apos;);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">$this-&gt;app-&gt;when(VideoController::class)</span><br><span class="line">          -&gt;needs(Filesystem::class)</span><br><span class="line">          -&gt;give(function () &#123;</span><br><span class="line">              return Storage::disk(&apos;s3&apos;);</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><p>上述表明，同样的接口Filesystem，使用依赖注入时，在PhotoController中获取的是local存储而在VideoController中获取的是s3存储。</p><h3 id="Contracts-amp-Facades（契约-amp-门面）"><a href="#Contracts-amp-Facades（契约-amp-门面）" class="headerlink" title="Contracts &amp; Facades（契约&amp;门面）"></a>Contracts &amp; Facades（契约&amp;门面）</h3><p>Laravel 还有一个强大之处是，比如你只需在配置文件中指明你需要的缓存驱动（redis，memcached，file……），Laravel 就自动办你切换到这种驱动，而不需要你针对某种驱动更改逻辑和代码。Why? 很简单，Laravel定义了一系列Contracts（翻译：契约），本质上是一系列PHP接口，一系列的标准，用来解耦具体需求对实现的依赖关系。其实真正强大的公司是制定标准的公司，程序也是如此，好的标准（接口）尤为重要。当程序变得越来大，这种通过合同或者接口来解耦所带来的可扩展性和可维护性是无可比拟的。</p><p><img src="/public/static/images/laravel生命周期/6.png" alt="Image text">  </p><p>上图不使用Contracts的情况下，对于一种逻辑，我们只能得到一种结果（方块），如果变更需求，意味着我们必须重构代码和逻辑。但是在使用Contracts的情况下，我们只需要按照接口写好逻辑，然后提供不同的实现，就可以在不改动代码逻辑的情况下获得更加多态的结果。</p><p>这么说有点抽象，举一个真实的例子。在完成Xblog的初期，我使用了缓存，所以导致Repository中充满了和cache相关的方法：remember，flush，forget等等。后来国外网友反映，简单的博客并不一定需要缓存。所以我决定把它变成可选，但因为代码中充满和cache相关的方法，实现起来并不是很容易。于是想起Laravel的重要概念Contracts。于是，我把与缓存有关的方法抽象出来形成一个Contracts:XblogCache，实际操作只与Contracts有关，这样问题就得到了解决，而几乎没有改变原有的逻辑。XblogCache的代码如下<a href="https://github.com/lufficc/Xblog/blob/master/app/Contracts/XblogCache.php" target="_blank" rel="noopener">源码点击这里</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace App\Contracts;</span><br><span class="line">use Closure;</span><br><span class="line">interface XblogCache</span><br><span class="line">&#123;</span><br><span class="line">    public function setTag($tag);</span><br><span class="line">    public function setTime($time_in_minute);</span><br><span class="line">    public function remember($key, Closure $entity, $tag = null);</span><br><span class="line">    public function forget($key, $tag = null);</span><br><span class="line">    public function clearCache($tag = null);</span><br><span class="line">    public function clearAllCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我又完成了两个实现类：Cacheable和NoCache：</p><p>1、实现具体缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Cacheable implements XblogCache</span><br><span class="line">&#123;</span><br><span class="line">    public $tag;</span><br><span class="line">    public $cacheTime;</span><br><span class="line">    public function setTag($tag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;tag = $tag;</span><br><span class="line">    &#125;</span><br><span class="line">    public function remember($key, Closure $entity, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        return cache()-&gt;tags($tag == null ? $this-&gt;tag : $tag)-&gt;remember($key, $this-&gt;cacheTime, $entity);</span><br><span class="line">    &#125;</span><br><span class="line">    public function forget($key, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        cache()-&gt;tags($tag == null ? $this-&gt;tag : $tag)-&gt;forget($key);</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearCache($tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        cache()-&gt;tags($tag == null ? $this-&gt;tag : $tag)-&gt;flush();</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearAllCache()</span><br><span class="line">    &#123;</span><br><span class="line">        cache()-&gt;flush();</span><br><span class="line">    &#125;</span><br><span class="line">    public function setTime($time_in_minute)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;cacheTime = $time_in_minute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1、不缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class NoCache implements XblogCache</span><br><span class="line">&#123;</span><br><span class="line">    public function setTag($tag)</span><br><span class="line">    &#123;</span><br><span class="line">    // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function setTime($time_in_minute)</span><br><span class="line">    &#123;</span><br><span class="line">    // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function remember($key, Closure $entity, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        /**</span><br><span class="line">         * directly return</span><br><span class="line">         */</span><br><span class="line">        return $entity();</span><br><span class="line">    &#125;</span><br><span class="line">    public function forget($key, $tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearCache($tag = null)</span><br><span class="line">    &#123;</span><br><span class="line">        // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">    public function clearAllCache()</span><br><span class="line">    &#123;</span><br><span class="line">        // Do Nothing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再利用容器的绑定，根据不同的配置，返回不同的实现<a href="https://github.com/lufficc/Xblog/blob/master/app/Providers/CacheServiceProvider.php#L28-L34" target="_blank" rel="noopener">源码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public function register()</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;app-&gt;bind(&apos;XblogCache&apos;, function ($app) &#123;</span><br><span class="line">        if (config(&apos;cache.enable&apos;) == &apos;true&apos;) &#123;</span><br><span class="line">            return new Cacheable();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new NoCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，就实现了缓存的切换而不需要更改你的具体逻辑代码。当然依靠接口而不依靠具体实现的好处不仅仅这些。实际上，Laravel所有的核心服务都是实现了某个Contracts接口（都在Illuminate\Contracts\文件夹下面），而不是依赖具体的实现，所以完全可以在不改动框架的前提下，使用自己的代码改变Laravel框架核心服务的实现方式。</p><p>说一说Facades。在我们学习了容器的概念后，Facades就变得十分简单了。在我们把类的实例绑定到容器的时候相当于给类起了个别名，然后覆盖Facade的静态方法getFacadeAccessor并返回你的别名，然后你就可以使用你自己的Facade的静态方法来调用你绑定类的动态方法了。其实Facade类利用了__callStatic() 这个魔术方法来延迟调用容器中的对象的方法，这里不过多讲解，你只需要知道Facade实现了将对它调用的静态方法映射到绑定类的动态方法上，这样你就可以使用简单类名调用而不需要记住长长的类名。这也是Facades的中文翻译为假象的原因</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Laravel强大之处不仅仅在于它给你提供了一系列脚手架，比如超级好用的ORM，基于Carbon的时间处理，以及文件存储等等功能。但是Laravel的核心非常非常简单：利用容器和抽象解耦，实现高扩展性。容器和抽象是所有大型框架必须解决的问题，像Java的Spring，Android的Dagger2等等都是围绕这几个问题的。所以本质上讲，Laravel之所以强大出名，是因为它的设计，思想，可扩展性。而Laravel的好用功能只是官方基于这些核心提供的脚手架，你同样也可以很轻松的添加自己的脚手架。</p><p>所以不要觉得Laravel强大是因为他提供的很多功能，而是它的设计模式和思想。</p><p>理解Laravel生命周期和请求的生命周期概念。<br>所有的静态变量和单例，在下一个请求到来时都会重新初始化。<br>将耗时的类或者频繁使用的类用singleton绑定。<br>将变化选项的抽象为Contracts，依赖接口不依赖具体实现。</p><p>本文转载至<a href="https://lufficc.com/blog/the-core-conception-of-laravel" target="_blank" rel="noopener">lufficc的网站</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工欲善其事，必先利其器。在开发Xblog的过程中，稍微领悟了一点Laravel的思想。确实如此，这篇文章读完你可能并不能从无到有写出一个博客，但知道Laravel的核心概念之后，当你再次写起Laravel时，会变得一目了然胸有成竹.  &lt;/p&gt;
&lt;h2 id=&quot;PHP的生命
      
    
    </summary>
    
      <category term="laravel" scheme="http://ioext.com/categories/laravel/"/>
    
    
      <category term="php" scheme="http://ioext.com/tags/php/"/>
    
      <category term="Laravel" scheme="http://ioext.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>swoole独立于apache、nginx启动SwooleFramweork</title>
    <link href="http://ioext.com/2017/10/17/swoole%E7%8B%AC%E7%AB%8B%E4%BA%8Eapache%E3%80%81nginx%E5%90%AF%E5%8A%A8SwooleFramweork/"/>
    <id>http://ioext.com/2017/10/17/swoole独立于apache、nginx启动SwooleFramweork/</id>
    <published>2017-10-16T16:15:42.000Z</published>
    <updated>2017-10-17T10:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>swoole是什么?请点击传送门</p><blockquote><p><a href="https://www.zhihu.com/question/35687627/answer/84459718" target="_blank" rel="noopener">Swoole到底是个什么东西</a></p></blockquote></li><li><p>swooleFramWork是什么?</p><blockquote><p>就是一个框架<br><a href="https://github.com/ioext/framework" target="_blank" rel="noopener">git地址</a></p></blockquote></li><li><p>其他的先不管,先把框架运行起来吧<br>通过上方git地址,将代码克隆到本地,然后在根目录创建server.php,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;DEAMON&apos;, false);</span><br><span class="line">//MVC define 加载MVC扩展插件</span><br><span class="line">define(&apos;MVCAPP&apos;, true);</span><br><span class="line">//定义web路径</span><br><span class="line">define(&apos;WEBPATH&apos;, realpath(__DIR__));</span><br><span class="line">//config file 自定义</span><br><span class="line">define(&apos;CONFIGFILE&apos;, WEBPATH . &apos;/http_config.ini&apos;);</span><br><span class="line">//Server Log File</span><br><span class="line">define(&apos;LOGFILE&apos;, WEBPATH . &apos;/logs/server.log&apos;);</span><br><span class="line">//定义APPPATH</span><br><span class="line">define(&apos;APPPATH&apos;, WEBPATH . &apos;/apps/&apos;);</span><br><span class="line">//包含配置文件</span><br><span class="line">require WEBPATH . &apos;/libs/lib_config.php&apos;;</span><br><span class="line">//关闭debug</span><br><span class="line">Swoole\Config::$debug = false;</span><br><span class="line">//设置PID文件的存储路径</span><br><span class="line">Swoole\Network\Server::setPidFile(__DIR__ . &apos;/logs/http_server.pid&apos;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 启动app server  独立于nginx apache</span><br><span class="line">* php http_server.php start|stop|reload   //配置默认路由</span><br><span class="line">*/</span><br><span class="line">Swoole\Network\Server::start(function () &#123;</span><br><span class="line">$server = Swoole\Protocol\WebServer::create(CONFIGFILE);</span><br><span class="line">//设置app的configs</span><br><span class="line">$server-&gt;setAppPath(APPPATH);</span><br><span class="line">$server-&gt;setLogger(new Swoole\Log\EchoLog(LOGFILE));</span><br><span class="line">//作为守护进程  生产环境开启 设置DEAMON=true</span><br><span class="line">if (DEAMON) &#123;</span><br><span class="line">$server-&gt;daemonize();</span><br><span class="line">&#125;</span><br><span class="line">//启动任务</span><br><span class="line">//$Task=Task::StartHomeworkCompletionCalcTask();</span><br><span class="line">//kill task</span><br><span class="line">//$Task-&gt;kill();</span><br><span class="line">//启动服务</span><br><span class="line">$server-&gt;run(array(&apos;worker_num&apos; =&gt; 1, &apos;react_num&apos; =&gt; 2, &apos;max_request&apos; =&gt; 500000, &apos;log_file&apos; =&gt; LOGFILE));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>然后创建http_config.ini文件,代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[request]</span><br><span class="line">default_page = &quot;index.php&quot;</span><br><span class="line"></span><br><span class="line">[server]</span><br><span class="line">host = &quot;0.0.0.0&quot;</span><br><span class="line">port = 7777</span><br><span class="line">max_request = 2000</span><br><span class="line">worker_num = 4</span><br><span class="line">webroot = &apos;http://127.0.0.1:7777&apos;</span><br><span class="line">process_rename = 1</span><br><span class="line">;是否保持长链接</span><br><span class="line">keepalive = 1</span><br><span class="line">;document root</span><br><span class="line">document_root=&quot;/Users/User/work/test/swoolef&quot;</span><br><span class="line">;gzip_open = 1</span><br><span class="line">user = www-data</span><br><span class="line">expire_open = 1</span><br><span class="line"></span><br><span class="line">[access]</span><br><span class="line">;拒绝访问的目录</span><br><span class="line">deny_dir = &quot;libs,class,templates,config&quot;</span><br><span class="line">;可访问的静态目录</span><br><span class="line">static_dir = &quot;static,&quot;</span><br><span class="line">;可访问的静态文件</span><br><span class="line">static_ext = &quot;js,jpg,gif,png,css,html,txt&quot;</span><br><span class="line">;php扩展</span><br><span class="line">dynamic_ext = &quot;php&quot;</span><br><span class="line">;post最大上传</span><br><span class="line">post_maxsize = 2000000</span><br><span class="line"></span><br><span class="line">[apps]</span><br><span class="line">charset = &quot;utf-8&quot;</span><br><span class="line">;是否处理静态文件 开关</span><br><span class="line">do_static = on</span><br></pre></td></tr></table></figure></p><p>最后根目录创建logs/文件夹。  </p><p>好了,现在你可以打开终端敲上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php server.php start -d</span><br></pre></td></tr></table></figure></p><p>验证是否开启:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep server.php</span><br></pre></td></tr></table></figure></p><p>然后在浏览器上输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7777</span><br></pre></td></tr></table></figure></p><p>ok</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;swoole是什么?请点击传送门&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/35687627/answer/84459718&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="swoole" scheme="http://ioext.com/tags/swoole/"/>
    
      <category term="SwooleFramework" scheme="http://ioext.com/tags/SwooleFramework/"/>
    
      <category term="php" scheme="http://ioext.com/tags/php/"/>
    
  </entry>
  
</feed>
